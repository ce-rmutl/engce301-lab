# 6.6.2 Backend Server Code Guide - Agent Wallboard System

## 🎯 Overview

เอกสารนี้จะอธิบายโครงสร้าง Backend Server ของ Agent Wallboard System ที่ใช้ **Node.js + Express + Socket.io** โดยเน้นการอธิบายไฟล์สำคัญที่นักศึกษาต้องทำงานด้วย พร้อมตัวอย่างโค้ดที่ใช้งานได้จริง

### 🎓 เป้าหมายการเรียนรู้
เมื่อจบการอ่านเอกสารนี้ นักศึกษาจะสามารถ:
- เข้าใจโครงสร้าง Node.js Backend ที่ทำงานได้จริง 80%
- รู้วิธีการใช้ API endpoints ที่มีให้
- เข้าใจการทำงานของ WebSocket สำหรับ real-time communication
- สามารถปรับแต่งและเพิ่ม features ใหม่ได้

---

## 🏗️ **Backend Architecture Overview**

### **📁 โครงสร้างไฟล์ที่สำคัญ**
```
backend-server/
├── 🚀 server.js                    # Entry point - เริ่มต้นทุกอย่าง (80% complete)
├── ⚙️ config/
│   └── 🗄️ database.js             # Database connections (90% complete)
├── 🛣️ routes/                      # API endpoints (85% complete)
│   ├── 🔐 auth.js                  # Login/logout APIs
│   ├── 👥 agents.js                # Agent management APIs
│   └── 💬 messages.js              # Message handling APIs
├── 🧠 models/                      # Database models (90% complete)
│   ├── 📄 Agent.js                 # SQLite agent model
│   └── 💬 Message.js               # MongoDB message model
├── 🔌 socket/                      # WebSocket handlers (75% complete)
│   └── ⚡ socketHandler.js         # Real-time event handling
└── 🛡️ middleware/                  # Middleware functions (95% complete)
    └── 🔐 auth.js                  # Authentication middleware
```

### **🔄 Request Flow Diagram**
```
📱 Client Request
    ↓
🛡️ CORS Middleware
    ↓
🔐 Authentication Middleware (ถ้าต้องการ)
    ↓
🛣️ Route Handler (auth.js, agents.js, messages.js)
    ↓
🧠 Database Model (Agent.js, Message.js)
    ↓
🗄️ Database (SQLite/MongoDB)
    ↓
📨 JSON Response
```

---

## 🚀 **Main Server File - server.js**

### **🎯 หน้าที่หลัก:**
- เริ่มต้น Express server
- ตั้งค่า WebSocket server
- เชื่อมต่อ databases
- จัดการ middleware และ routes

### **📋 Code Walkthrough:**
```javascript
// ========== DEPENDENCIES ==========
const express = require('express');
const http = require('http');
const socketio = require('socket.io');
const cors = require('cors');
require('dotenv').config();

// ========== IMPORTS ==========
// Import route handlers
const authRoutes = require('./routes/auth');
const agentRoutes = require('./routes/agents');
const messageRoutes = require('./routes/messages');

// Import WebSocket handler
const socketHandler = require('./socket/socketHandler');

// Import database configuration
const { connectMongoDB, initSQLite } = require('./config/database');

// ========== SERVER SETUP ==========
const app = express();
const server = http.createServer(app);

// Setup Socket.io with CORS
const io = socketio(server, {
  cors: {
    origin: process.env.CORS_ORIGIN || "http://localhost:3000",
    methods: ["GET", "POST", "PUT", "DELETE"]
  }
});

// ========== MIDDLEWARE ==========
app.use(cors({
  origin: process.env.CORS_ORIGIN || "http://localhost:3000",
  credentials: true
}));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Request logging middleware (for development)
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  next();
});

// ========== API ROUTES ==========
app.use('/api/auth', authRoutes);
app.use('/api/agents', agentRoutes);
app.use('/api/messages', messageRoutes);

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    message: 'Agent Wallboard Server is running',
    timestamp: new Date().toISOString()
  });
});

// Test database endpoint
app.get('/api/test/database', async (req, res) => {
  try {
    // Test SQLite connection
    const { getSQLiteDB } = require('./config/database');
    const db = getSQLiteDB();
    
    // Test MongoDB connection
    const mongoose = require('mongoose');
    
    res.json({
      sqlite: db ? 'connected' : 'disconnected',
      mongodb: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
      sampleData: 'available'
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ========== WEBSOCKET SETUP ==========
socketHandler(io);

// ========== ERROR HANDLING ==========
app.use((err, req, res, next) => {
  console.error('Server Error:', err);
  res.status(500).json({ 
    error: 'Internal Server Error',
    message: process.env.NODE_ENV === 'development' ? err.message : 'Something went wrong'
  });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ error: 'Route not found' });
});

// ========== SERVER STARTUP ==========
async function startServer() {
  try {
    console.log('🚀 Starting Agent Wallboard Server...');
    
    // Initialize databases
    console.log('📊 Connecting to databases...');
    await initSQLite();
    await connectMongoDB();
    
    // Start server
    const PORT = process.env.PORT || 3001;
    server.listen(PORT, () => {
      console.log(`✅ Server running on port ${PORT}`);
      console.log(`📊 Health check: http://localhost:${PORT}/health`);
      console.log(`🌐 CORS origin: ${process.env.CORS_ORIGIN || "http://localhost:3000"}`);
    });
    
  } catch (error) {
    console.error('❌ Failed to start server:', error);
    process.exit(1);
  }
}

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('\n🛑 Shutting down server...');
  server.close(() => {
    console.log('✅ Server closed');
    process.exit(0);
  });
});

// Start the server
startServer();

module.exports = { app, server, io };
```

### **🎯 ส่วนที่นักศึกษาจะแก้ไข:**
- **CORS settings** - เพิ่ม domains ที่อนุญาต
- **Middleware** - เพิ่ม logging หรือ security middleware
- **Routes** - เพิ่ม API endpoints ใหม่
- **Error handling** - ปรับปรุงการจัดการ errors

---

## 🗄️ **Database Configuration - config/database.js**

### **🎯 หน้าที่หลัก:**
- จัดการการเชื่อมต่อ SQLite และ MongoDB
- ให้ functions สำหรับเข้าถึง databases
- Handle connection errors

### **📋 Code Walkthrough:**
```javascript
// ========== DEPENDENCIES ==========
const sqlite3 = require('sqlite3').verbose();
const mongoose = require('mongoose');
const path = require('path');

let sqliteDb = null;

// ========== SQLITE CONNECTION ==========
function initSQLite() {
  return new Promise((resolve, reject) => {
    const dbPath = process.env.SQLITE_DB_PATH || path.join(__dirname, '../database/sqlite/wallboard.db');
    
    console.log(`📊 Connecting to SQLite: ${dbPath}`);
    
    sqliteDb = new sqlite3.Database(dbPath, (err) => {
      if (err) {
        console.error('❌ SQLite connection error:', err.message);
        reject(err);
      } else {
        console.log('✅ Connected to SQLite database');
        resolve();
      }
    });
  });
}

// ========== MONGODB CONNECTION ==========
async function connectMongoDB() {
  try {
    const mongoUri = process.env.MONGODB_URI || 'mongodb://localhost:27017/wallboard';
    
    console.log(`🍃 Connecting to MongoDB: ${mongoUri}`);
    
    await mongoose.connect(mongoUri, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      serverSelectionTimeoutMS: 5000, // 5 second timeout
    });
    
    console.log('✅ Connected to MongoDB');
    
    // Handle MongoDB connection events
    mongoose.connection.on('error', (err) => {
      console.error('❌ MongoDB error:', err);
    });
    
    mongoose.connection.on('disconnected', () => {
      console.log('📴 MongoDB disconnected');
    });
    
  } catch (error) {
    console.error('❌ MongoDB connection error:', error.message);
    throw error;
  }
}

// ========== HELPER FUNCTIONS ==========
function getSQLiteDB() {
  if (!sqliteDb) {
    throw new Error('SQLite database not initialized. Call initSQLite() first.');
  }
  return sqliteDb;
}

function closeDatabases() {
  return new Promise((resolve) => {
    // Close SQLite
    if (sqliteDb) {
      sqliteDb.close((err) => {
        if (err) console.error('Error closing SQLite:', err);
        else console.log('📊 SQLite connection closed');
      });
    }
    
    // Close MongoDB
    mongoose.connection.close(() => {
      console.log('🍃 MongoDB connection closed');
      resolve();
    });
  });
}

// ========== EXPORTS ==========
module.exports = {
  initSQLite,
  connectMongoDB,
  getSQLiteDB,
  closeDatabases
};
```

### **🎯 ส่วนที่นักศึกษาจะแก้ไข:**
- **Database paths** - ปรับ path ให้เหมาะสม
- **Connection options** - เพิ่ม timeout, retry logic
- **Error handling** - ปรับปรุงการจัดการ connection errors

---

## 🔐 **Authentication Routes - routes/auth.js**

### **🎯 หน้าที่หลัก:**
- จัดการ agent login (ไม่มี password)
- ตรวจสอบ agent code กับ database
- ส่งข้อมูล agent กลับไป

### **📋 Code Walkthrough:**
```javascript
// ========== DEPENDENCIES ==========
const express = require('express');
const { getSQLiteDB } = require('../config/database');
const router = express.Router();

// ========== LOGIN ENDPOINT ==========
router.post('/login', async (req, res) => {
  try {
    const { agentCode } = req.body;
    
    // Validate input
    if (!agentCode) {
      return res.status(400).json({ 
        error: 'Agent code is required',
        message: 'กรุณาใส่รหัสเจ้าหน้าที่'
      });
    }
    
    // Clean agent code (remove spaces, uppercase)
    const cleanAgentCode = agentCode.trim().toUpperCase();
    
    console.log(`🔐 Login attempt: ${cleanAgentCode}`);
    
    // Query database
    const db = getSQLiteDB();
    const query = `
      SELECT 
        a.agent_code,
        a.agent_name,
        a.team_id,
        a.role,
        a.email,
        a.is_active,
        t.team_name
      FROM agents a 
      LEFT JOIN teams t ON a.team_id = t.team_id 
      WHERE a.agent_code = ? AND a.is_active = 1
    `;
    
    db.get(query, [cleanAgentCode], (err, agent) => {
      if (err) {
        console.error('Database error:', err);
        return res.status(500).json({ 
          error: 'Database error',
          message: 'เกิดข้อผิดพลาดในระบบ'
        });
      }
      
      if (!agent) {
        console.log(`❌ Agent not found: ${cleanAgentCode}`);
        return res.status(401).json({ 
          error: 'Invalid agent code',
          message: 'ไม่พบรหัสเจ้าหน้าที่ในระบบ'
        });
      }
      
      console.log(`✅ Login successful: ${agent.agent_name}`);
      
      // Return agent data (no password needed)
      res.json({
        success: true,
        message: 'เข้าสู่ระบบสำเร็จ',
        agent: {
          agentCode: agent.agent_code,
          agentName: agent.agent_name,
          teamId: agent.team_id,
          teamName: agent.team_name,
          role: agent.role,
          email: agent.email
        }
      });
    });
    
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ 
      error: 'Internal server error',
      message: 'เกิดข้อผิดพลาดในระบบ'
    });
  }
});

// ========== VERIFY AGENT ENDPOINT ==========
router.get('/verify/:agentCode', (req, res) => {
  try {
    const { agentCode } = req.params;
    
    if (!agentCode) {
      return res.status(400).json({ error: 'Agent code is required' });
    }
    
    const db = getSQLiteDB();
    const query = `
      SELECT agent_code, agent_name, role, is_active 
      FROM agents 
      WHERE agent_code = ?
    `;
    
    db.get(query, [agentCode.toUpperCase()], (err, agent) => {
      if (err) {
        return res.status(500).json({ error: 'Database error' });
      }
      
      res.json({
        exists: !!agent,
        active: agent ? agent.is_active === 1 : false,
        role: agent ? agent.role : null
      });
    });
    
  } catch (error) {
    console.error('Verify error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ========== GET ALL AGENTS (for testing) ==========
router.get('/agents/all', (req, res) => {
  try {
    const db = getSQLiteDB();
    const query = `
      SELECT 
        a.agent_code,
        a.agent_name,
        a.role,
        t.team_name,
        a.is_active
      FROM agents a 
      LEFT JOIN teams t ON a.team_id = t.team_id 
      ORDER BY a.role, a.agent_name
    `;
    
    db.all(query, [], (err, agents) => {
      if (err) {
        return res.status(500).json({ error: 'Database error' });
      }
      
      res.json({
        success: true,
        agents: agents,
        count: agents.length
      });
    });
    
  } catch (error) {
    console.error('Get agents error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

module.exports = router;
```

### **🧪 Testing the Auth API:**
```bash
# Test login
curl -X POST http://localhost:3001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"agentCode":"AG001"}'

# Test verify
curl http://localhost:3001/api/auth/verify/AG001

# Get all agents (for testing)
curl http://localhost:3001/api/auth/agents/all
```

### **🎯 ส่วนที่นักศึกษาจะแก้ไข:**
- **Input validation** - เพิ่ม validation rules
- **Error messages** - ปรับข้อความให้เหมาะสม
- **Logging** - เพิ่ม audit logs
- **Security** - เพิ่ม rate limiting

---

## 👥 **Agent Routes - routes/agents.js**

### **🎯 หน้าที่หลัก:**
- จัดการข้อมูล agents
- อัปเดต agent status
- ดึงข้อมูล team members

### **📋 Code Walkthrough:**
```javascript
// ========== DEPENDENCIES ==========
const express = require('express');
const { getSQLiteDB } = require('../config/database');
const router = express.Router();

// ========== GET TEAM AGENTS ==========
router.get('/team/:teamId', (req, res) => {
  try {
    const { teamId } = req.params;
    
    const db = getSQLiteDB();
    const query = `
      SELECT 
        a.agent_code,
        a.agent_name,
        a.role,
        a.email,
        t.team_name
      FROM agents a
      LEFT JOIN teams t ON a.team_id = t.team_id
      WHERE a.team_id = ? AND a.is_active = 1 AND a.role = 'agent'
      ORDER BY a.agent_name
    `;
    
    db.all(query, [teamId], (err, agents) => {
      if (err) {
        console.error('Database error:', err);
        return res.status(500).json({ error: 'Database error' });
      }
      
      res.json({
        success: true,
        teamId: parseInt(teamId),
        agents: agents,
        count: agents.length
      });
    });
    
  } catch (error) {
    console.error('Get team agents error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ========== GET AGENT PROFILE ==========
router.get('/profile/:agentCode', (req, res) => {
  try {
    const { agentCode } = req.params;
    
    const db = getSQLiteDB();
    const query = `
      SELECT 
        a.agent_code,
        a.agent_name,
        a.team_id,
        a.role,
        a.email,
        a.phone,
        a.hire_date,
        t.team_name,
        t.supervisor_code
      FROM agents a
      LEFT JOIN teams t ON a.team_id = t.team_id
      WHERE a.agent_code = ? AND a.is_active = 1
    `;
    
    db.get(query, [agentCode.toUpperCase()], (err, agent) => {
      if (err) {
        return res.status(500).json({ error: 'Database error' });
      }
      
      if (!agent) {
        return res.status(404).json({ error: 'Agent not found' });
      }
      
      res.json({
        success: true,
        agent: agent
      });
    });
    
  } catch (error) {
    console.error('Get agent profile error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ========== UPDATE AGENT STATUS (for future use) ==========
router.put('/status/:agentCode', (req, res) => {
  try {
    const { agentCode } = req.params;
    const { status, timestamp } = req.body;
    
    // Validate status
    const validStatuses = ['Available', 'Busy', 'Break', 'Meeting', 'Offline'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({ 
        error: 'Invalid status',
        validStatuses: validStatuses
      });
    }
    
    console.log(`📊 Status update: ${agentCode} -> ${status}`);
    
    // For now, just acknowledge the update
    // In Week 2, students will implement MongoDB logging here
    res.json({
      success: true,
      message: 'Status updated successfully',
      agentCode: agentCode,
      status: status,
      timestamp: timestamp || new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Update status error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ========== GET ALL TEAMS ==========
router.get('/teams/all', (req, res) => {
  try {
    const db = getSQLiteDB();
    const query = `
      SELECT 
        t.team_id,
        t.team_name,
        t.supervisor_code,
        t.description,
        COUNT(a.agent_code) as agent_count
      FROM teams t
      LEFT JOIN agents a ON t.team_id = a.team_id AND a.role = 'agent' AND a.is_active = 1
      WHERE t.is_active = 1
      GROUP BY t.team_id, t.team_name, t.supervisor_code, t.description
      ORDER BY t.team_name
    `;
    
    db.all(query, [], (err, teams) => {
      if (err) {
        return res.status(500).json({ error: 'Database error' });
      }
      
      res.json({
        success: true,
        teams: teams,
        count: teams.length
      });
    });
    
  } catch (error) {
    console.error('Get teams error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

module.exports = router;
```

### **🧪 Testing the Agents API:**
```bash
# Get team agents
curl http://localhost:3001/api/agents/team/1

# Get agent profile
curl http://localhost:3001/api/agents/profile/AG001

# Update agent status
curl -X PUT http://localhost:3001/api/agents/status/AG001 \
  -H "Content-Type: application/json" \
  -d '{"status":"Break","timestamp":"2024-09-22T10:30:00Z"}'

# Get all teams
curl http://localhost:3001/api/agents/teams/all
```

---

## 💬 **Message Routes - routes/messages.js**

### **🎯 หน้าที่หลัก:**
- ส่งข้อความ direct และ broadcast
- บันทึกข้อความลง MongoDB
- ดึงประวัติข้อความ

### **📋 Code Walkthrough:**
```javascript
// ========== DEPENDENCIES ==========
const express = require('express');
const Message = require('../models/Message'); // MongoDB model
const router = express.Router();

// ========== SEND MESSAGE ==========
router.post('/send', async (req, res) => {
  try {
    const { fromCode, toCode, message, type = 'direct', priority = 'normal' } = req.body;
    
    // Validate input
    if (!fromCode || !message) {
      return res.status(400).json({ 
        error: 'Missing required fields',
        required: ['fromCode', 'message']
      });
    }
    
    if (type === 'direct' && !toCode) {
      return res.status(400).json({ 
        error: 'toCode is required for direct messages'
      });
    }
    
    console.log(`💬 New ${type} message from ${fromCode}${toCode ? ` to ${toCode}` : ' (broadcast)'}`);
    
    // Create message object
    const newMessage = new Message({
      fromCode: fromCode.toUpperCase(),
      toCode: type === 'direct' ? toCode.toUpperCase() : null,
      message: message.trim(),
      type: type,
      priority: priority,
      timestamp: new Date(),
      isRead: false
    });
    
    // Save to MongoDB
    const savedMessage = await newMessage.save();
    
    res.json({
      success: true,
      message: 'Message sent successfully',
      messageId: savedMessage._id,
      data: {
        fromCode: savedMessage.fromCode,
        toCode: savedMessage.toCode,
        message: savedMessage.message,
        type: savedMessage.type,
        timestamp: savedMessage.timestamp
      }
    });
    
  } catch (error) {
    console.error('Send message error:', error);
    res.status(500).json({ 
      error: 'Failed to send message',
      details: error.message
    });
  }
});

// ========== GET MESSAGES FOR AGENT ==========
router.get('/agent/:agentCode', async (req, res) => {
  try {
    const { agentCode } = req.params;
    const { limit = 50, page = 1 } = req.query;
    
    const skip = (parseInt(page) - 1) * parseInt(limit);
    
    // Get direct messages to this agent + broadcast messages
    const messages = await Message.find({
      $or: [
        { toCode: agentCode.toUpperCase() }, // Direct messages
        { toCode: null, type: 'broadcast' }  // Broadcast messages
      ]
    })
    .sort({ timestamp: -1 })
    .limit(parseInt(limit))
    .skip(skip)
    .lean();
    
    res.json({
      success: true,
      agentCode: agentCode.toUpperCase(),
      messages: messages,
      count: messages.length,
      page: parseInt(page),
      limit: parseInt(limit)
    });
    
  } catch (error) {
    console.error('Get messages error:', error);
    res.status(500).json({ error: 'Failed to get messages' });
  }
});

// ========== MARK MESSAGE AS READ ==========
router.put('/read/:messageId', async (req, res) => {
  try {
    const { messageId } = req.params;
    const { agentCode } = req.body;
    
    const updatedMessage = await Message.findByIdAndUpdate(
      messageId,
      { 
        isRead: true, 
        readAt: new Date(),
        readBy: agentCode 
      },
      { new: true }
    );
    
    if (!updatedMessage) {
      return res.status(404).json({ error: 'Message not found' });
    }
    
    res.json({
      success: true,
      message: 'Message marked as read',
      messageId: messageId
    });
    
  } catch (error) {
    console.error('Mark read error:', error);
    res.status(500).json({ error: 'Failed to mark message as read' });
  }
});

// ========== GET MESSAGE HISTORY (for supervisors) ==========
router.get('/history/:fromCode', async (req, res) => {
  try {
    const { fromCode } = req.params;
    const { limit = 100 } = req.query;
    
    const messages = await Message.find({
      fromCode: fromCode.toUpperCase()
    })
    .sort({ timestamp: -1 })
    .limit(parseInt(limit))
    .lean();
    
    res.json({
      success: true,
      fromCode: fromCode.toUpperCase(),
      messages: messages,
      count: messages.length
    });
    
  } catch (error) {
    console.error('Get history error:', error);
    res.status(500).json({ error: 'Failed to get message history' });
  }
});

module.exports = router;
```

### **🧪 Testing the Messages API:**
```bash
# Send direct message
curl -X POST http://localhost:3001/api/messages/send \
  -H "Content-Type: application/json" \
  -d '{"fromCode":"SP001","toCode":"AG001","message":"Please update your status","type":"direct"}'

# Send broadcast message  
curl -X POST http://localhost:3001/api/messages/send \
  -H "Content-Type: application/json" \
  -d '{"fromCode":"SP001","message":"Team meeting at 2 PM","type":"broadcast","priority":"high"}'

# Get messages for agent
curl http://localhost:3001/api/messages/agent/AG001?limit=10

# Mark message as read
curl -X PUT http://localhost:3001/api/messages/read/MESSAGE_ID \
  -H "Content-Type: application/json" \
  -d '{"agentCode":"AG001"}'
```

---

## ⚡ **WebSocket Handler - socket/socketHandler.js**

### **🎯 หน้าที่หลัก:**
- จัดการ WebSocket connections
- Handle real-time events (status changes, messages)
- Broadcast updates ไปยัง connected clients

### **📋 Code Walkthrough:**
```javascript
// ========== DEPENDENCIES ==========
const Message = require('../models/Message');

// Keep track of connected clients
const activeConnections = new Map(); // agentCode -> socketId
const supervisorConnections = new Map(); // supervisorCode -> socketId

function socketHandler(io) {
  console.log('⚡ WebSocket server initialized');
  
  io.on('connection', (socket) => {
    console.log('🔌 New client connected:', socket.id);
    
    // ========== AGENT CONNECTION ==========
    socket.on('agent_connect', (data) => {
      try {
        const { agentCode } = data;
        
        if (!agentCode) {
          socket.emit('connection_error', { message: 'Agent code required' });
          return;
        }
        
        const cleanAgentCode = agentCode.toUpperCase();
        
        // Store connection
        activeConnections.set(cleanAgentCode, socket.id);
        socket.agentCode = cleanAgentCode;
        socket.join(`agent_${cleanAgentCode}`);
        
        console.log(`👤 Agent connected: ${cleanAgentCode}`);
        
        // Confirm connection
        socket.emit('agent_connected', {
          agentCode: cleanAgentCode,
          timestamp: new Date().toISOString()
        });
        
        // Notify supervisors about agent coming online
        socket.broadcast.emit('agent_status_change', {
          agentCode: cleanAgentCode,
          status: 'Available',
          timestamp: new Date().toISOString(),
          isOnline: true
        });
        
      } catch (error) {
        console.error('Agent connect error:', error);
        socket.emit('connection_error', { message: 'Connection failed' });
      }
    });
    
    // ========== SUPERVISOR CONNECTION ==========
    socket.on('supervisor_connect', (data) => {
      try {
        const { supervisorCode } = data;
        
        if (!supervisorCode) {
          socket.emit('connection_error', { message: 'Supervisor code required' });
          return;
        }
        
        const cleanSupervisorCode = supervisorCode.toUpperCase();
        
        // Store connection
        supervisorConnections.set(cleanSupervisorCode, socket.id);
        socket.supervisorCode = cleanSupervisorCode;
        socket.join(`supervisor_${cleanSupervisorCode}`);
        
        console.log(`👨‍💼 Supervisor connected: ${cleanSupervisorCode}`);
        
        // Confirm connection
        socket.emit('supervisor_connected', {
          supervisorCode: cleanSupervisorCode,
          timestamp: new Date().toISOString()
        });
        
      } catch (error) {
        console.error('Supervisor connect error:', error);
        socket.emit('connection_error', { message: 'Connection failed' });
      }
    });
    
    // ========== AGENT STATUS UPDATE ==========
    socket.on('update_agent_status', (data) => {
      try {
        const { agentCode, status, timestamp } = data;
        
        if (!agentCode || !status) {
          socket.emit('status_error', { message: 'Agent code and status required' });
          return;
        }
        
        const validStatuses = ['Available', 'Busy', 'Break', 'Meeting', 'Offline'];
        if (!validStatuses.includes(status)) {
          socket.emit('status_error', { message: 'Invalid status' });
          return;
        }
        
        console.log(`📊 Status update: ${agentCode} -> ${status}`);
        
        // Broadcast status change to all supervisors
        socket.broadcast.emit('agent_status_change', {
          agentCode: agentCode.toUpperCase(),
          status: status,
          timestamp: timestamp || new Date().toISOString(),
          isOnline: true
        });
        
        // Confirm to agent
        socket.emit('status_updated', {
          agentCode: agentCode.toUpperCase(),
          status: status,
          timestamp: timestamp || new Date().toISOString()
        });
        
        // TODO: Week 2 - Save to MongoDB here
        
      } catch (error) {
        console.error('Status update error:', error);
        socket.emit('status_error', { message: 'Failed to update status' });
      }
    });
    
    // ========== SEND DIRECT MESSAGE ==========
    socket.on('send_direct_message', async (data) => {
      try {
        const { fromCode, toCode, message, priority = 'normal' } = data;
        
        if (!fromCode || !toCode || !message) {
          socket.emit('message_error', { message: 'Missing required fields' });
          return;
        }
        
        console.log(`💬 Direct message: ${fromCode} -> ${toCode}`);
        
        // Save to MongoDB
        const newMessage = new Message({
          fromCode: fromCode.toUpperCase(),
          toCode: toCode.toUpperCase(),
          message: message.trim(),
          type: 'direct',
          priority: priority,
          timestamp: new Date(),
          isRead: false
        });
        
        const savedMessage = await newMessage.save();
        
        // Send to target agent
        const targetSocketId = activeConnections.get(toCode.toUpperCase());
        if (targetSocketId) {
          io.to(targetSocketId).emit('new_direct_message', {
            messageId: savedMessage._id,
            fromCode: savedMessage.fromCode,
            message: savedMessage.message,
            priority: savedMessage.priority,
            timestamp: savedMessage.timestamp
          });
        }
        
        // Confirm to sender
        socket.emit('message_sent', {
          messageId: savedMessage._id,
          toCode: savedMessage.toCode,
          timestamp: savedMessage.timestamp
        });
        
      } catch (error) {
        console.error('Direct message error:', error);
        socket.emit('message_error', { message: 'Failed to send message' });
      }
    });
    
    // ========== SEND BROADCAST MESSAGE ==========
    socket.on('send_broadcast_message', async (data) => {
      try {
        const { fromCode, message, priority = 'normal' } = data;
        
        if (!fromCode || !message) {
          socket.emit('message_error', { message: 'Missing required fields' });
          return;
        }
        
        console.log(`📢 Broadcast message from: ${fromCode}`);
        
        // Save to MongoDB
        const newMessage = new Message({
          fromCode: fromCode.toUpperCase(),
          toCode: null, // null for broadcast
          message: message.trim(),
          type: 'broadcast',
          priority: priority,
          timestamp: new Date(),
          isRead: false
        });
        
        const savedMessage = await newMessage.save();
        
        // Broadcast to all connected agents
        socket.broadcast.emit('new_broadcast_message', {
          messageId: savedMessage._id,
          fromCode: savedMessage.fromCode,
          message: savedMessage.message,
          priority: savedMessage.priority,
          timestamp: savedMessage.timestamp
        });
        
        // Confirm to sender
        socket.emit('broadcast_sent', {
          messageId: savedMessage._id,
          timestamp: savedMessage.timestamp,
          recipientCount: activeConnections.size
        });
        
      } catch (error) {
        console.error('Broadcast message error:', error);
        socket.emit('message_error', { message: 'Failed to send broadcast' });
      }
    });
    
    // ========== GET CONNECTED AGENTS ==========
    socket.on('get_connected_agents', () => {
      try {
        const connectedAgents = Array.from(activeConnections.keys());
        
        socket.emit('connected_agents_list', {
          agents: connectedAgents,
          count: connectedAgents.length,
          timestamp: new Date().toISOString()
        });
        
      } catch (error) {
        console.error('Get connected agents error:', error);
        socket.emit('connection_error', { message: 'Failed to get agent list' });
      }
    });
    
    // ========== DISCONNECT HANDLING ==========
    socket.on('disconnect', (reason) => {
      console.log(`👋 Client disconnected: ${socket.id}, reason: ${reason}`);
      
      try {
        // Remove from agent connections
        if (socket.agentCode) {
          activeConnections.delete(socket.agentCode);
          
          // Notify supervisors that agent went offline
          socket.broadcast.emit('agent_status_change', {
            agentCode: socket.agentCode,
            status: 'Offline',
            timestamp: new Date().toISOString(),
            isOnline: false
          });
          
          console.log(`👤 Agent disconnected: ${socket.agentCode}`);
        }
        
        // Remove from supervisor connections
        if (socket.supervisorCode) {
          supervisorConnections.delete(socket.supervisorCode);
          console.log(`👨‍💼 Supervisor disconnected: ${socket.supervisorCode}`);
        }
        
      } catch (error) {
        console.error('Disconnect handling error:', error);
      }
    });
    
    // ========== PING/PONG FOR CONNECTION HEALTH ==========
    socket.on('ping', () => {
      socket.emit('pong', { timestamp: new Date().toISOString() });
    });
    
  });
  
  // ========== PERIODIC CONNECTION STATUS ==========
  setInterval(() => {
    const stats = {
      connectedAgents: activeConnections.size,
      connectedSupervisors: supervisorConnections.size,
      totalConnections: io.engine.clientsCount,
      timestamp: new Date().toISOString()
    };
    
    console.log(`📊 Connection stats:`, stats);
    
    // Broadcast stats to supervisors
    io.emit('connection_stats', stats);
  }, 30000); // Every 30 seconds
}

module.exports = socketHandler;
```

### **🧪 Testing WebSocket Events:**
```javascript
// Test WebSocket connection (in browser console or test file)
const socket = io('http://localhost:3001');

// Agent connection
socket.emit('agent_connect', { agentCode: 'AG001' });

// Status update
socket.emit('update_agent_status', { 
  agentCode: 'AG001', 
  status: 'Break' 
});

// Send direct message
socket.emit('send_direct_message', {
  fromCode: 'SP001',
  toCode: 'AG001', 
  message: 'Please update your status'
});

// Listen for events
socket.on('agent_connected', (data) => console.log('Connected:', data));
socket.on('new_direct_message', (data) => console.log('New message:', data));
socket.on('agent_status_change', (data) => console.log('Status change:', data));
```

---

## 🧠 **Database Models**

### **📄 SQLite Model - models/Agent.js**
```javascript
// ========== DEPENDENCIES ==========
const { getSQLiteDB } = require('../config/database');

class Agent {
  // ========== FIND AGENT BY CODE ==========
  static async findByCode(agentCode) {
    return new Promise((resolve, reject) => {
      const db = getSQLiteDB();
      const query = `
        SELECT a.*, t.team_name 
        FROM agents a 
        LEFT JOIN teams t ON a.team_id = t.team_id 
        WHERE a.agent_code = ? AND a.is_active = 1
      `;
      
      db.get(query, [agentCode], (err, row) => {
        if (err) {
          reject(err);
        } else {
          resolve(row);
        }
      });
    });
  }
  
  // ========== FIND AGENTS BY TEAM ==========
  static async findByTeam(teamId) {
    return new Promise((resolve, reject) => {
      const db = getSQLiteDB();
      const query = `
        SELECT agent_code, agent_name, role, email
        FROM agents 
        WHERE team_id = ? AND is_active = 1 AND role = 'agent'
        ORDER BY agent_name
      `;
      
      db.all(query, [teamId], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows);
        }
      });
    });
  }
  
  // ========== GET ALL SUPERVISORS ==========
  static async getAllSupervisors() {
    return new Promise((resolve, reject) => {
      const db = getSQLiteDB();
      const query = `
        SELECT a.*, t.team_name
        FROM agents a
        LEFT JOIN teams t ON a.team_id = t.team_id
        WHERE a.role = 'supervisor' AND a.is_active = 1
        ORDER BY a.agent_name
      `;
      
      db.all(query, [], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows);
        }
      });
    });
  }
}

module.exports = Agent;
```

### **💬 MongoDB Model - models/Message.js**
```javascript
// ========== DEPENDENCIES ==========
const mongoose = require('mongoose');

// ========== MESSAGE SCHEMA ==========
const messageSchema = new mongoose.Schema({
  fromCode: {
    type: String,
    required: true,
    index: true,
    uppercase: true
  },
  toCode: {
    type: String,
    index: true,
    uppercase: true,
    default: null // null for broadcast messages
  },
  message: {
    type: String,
    required: true,
    maxlength: 1000,
    trim: true
  },
  type: {
    type: String,
    enum: ['direct', 'broadcast'],
    default: 'direct'
  },
  priority: {
    type: String,
    enum: ['low', 'normal', 'high', 'urgent'],
    default: 'normal'
  },
  timestamp: {
    type: Date,
    default: Date.now,
    index: true
  },
  isRead: {
    type: Boolean,
    default: false
  },
  readAt: {
    type: Date,
    default: null
  },
  readBy: {
    type: String,
    default: null
  }
}, {
  collection: 'messages',
  timestamps: true // adds createdAt and updatedAt
});

// ========== INDEXES FOR PERFORMANCE ==========
messageSchema.index({ toCode: 1, timestamp: -1 });
messageSchema.index({ fromCode: 1, timestamp: -1 });
messageSchema.index({ type: 1, timestamp: -1 });

// ========== STATIC METHODS ==========
messageSchema.statics.getMessagesForAgent = function(agentCode, limit = 50) {
  return this.find({
    $or: [
      { toCode: agentCode },
      { toCode: null, type: 'broadcast' }
    ]
  })
  .sort({ timestamp: -1 })
  .limit(limit)
  .lean();
};

messageSchema.statics.getMessageHistory = function(fromCode, limit = 100) {
  return this.find({ fromCode: fromCode })
    .sort({ timestamp: -1 })
    .limit(limit)
    .lean();
};

// ========== CREATE MODEL ==========
const Message = mongoose.model('Message', messageSchema);

module.exports = Message;
```

---

## 🎯 **สิ่งที่นักศึกษาจะทำใน 2 สัปดาห์**

### **✅ Week 1: เข้าใจและปรับแต่ง (งานง่าย 70%)**
```
📋 Day 1-2: ทำความเข้าใจโค้ด
├── รัน backend server ให้ได้
├── ทดสอบ API endpoints ด้วย Postman
├── เข้าใจ WebSocket events
└── ทดสอบการเชื่อมต่อ database

📋 Day 3-4: ปรับแต่งพื้นฐาน
├── เปลี่ยน error messages เป็นภาษาไทย
├── เพิ่ม console.log สำหรับ debugging
├── ปรับแต่ง CORS settings
└── เพิ่ม input validation

📋 Day 5-7: ทดสอบ Integration
├── เชื่อมต่อกับ frontend applications
├── ทดสอบ real-time features
├── แก้ไข bugs ที่เจอ
└── เขียน documentation พื้นฐาน
```

### **🚀 Week 2: เพิ่มฟีเจอร์ใหม่ (งานท้าทาย 30%)**
```
📋 Advanced Features:
├── เพิ่ม API endpoint สำหรับ team statistics
├── เพิ่ม message templates ใน database
├── ปรับปรุง WebSocket error handling  
├── เพิ่ม rate limiting สำหรับ API
└── เพิ่ม basic logging system

📋 Integration & Testing:
├── Integration testing กับ frontend
├── Performance testing กับหลาย ๆ users
├── Error scenarios testing
└── Documentation ที่สมบูรณ์
```

---

## 🧪 **Complete API Testing Guide**

### **📋 Postman Collection สำหรับทดสอบ:**
```javascript
// Import ลงใน Postman
{
  "name": "Agent Wallboard API",
  "requests": [
    {
      "name": "Health Check",
      "method": "GET",
      "url": "http://localhost:3001/health"
    },
    {
      "name": "Agent Login",
      "method": "POST", 
      "url": "http://localhost:3001/api/auth/login",
      "body": {
        "agentCode": "AG001"
      }
    },
    {
      "name": "Get Team Agents",
      "method": "GET",
      "url": "http://localhost:3001/api/agents/team/1"
    },
    {
      "name": "Send Direct Message",
      "method": "POST",
      "url": "http://localhost:3001/api/messages/send",
      "body": {
        "fromCode": "SP001",
        "toCode": "AG001", 
        "message": "Please update your status",
        "type": "direct"
      }
    }
  ]
}
```

### **🔧 Development Scripts:**
```bash
# Start development server with auto-restart
npm run dev

# Test all API endpoints
npm run test:api

# Check database connections  
npm run test:db

# Run with debug logging
DEBUG=* npm run dev
```

---

## ✅ **Backend Completion Checklist**

### **📋 พื้นฐานที่ต้องทำงานได้:**
- [ ] Server เริ่มต้นได้โดยไม่มี errors
- [ ] เชื่อมต่อ SQLite และ MongoDB สำเร็จ
- [ ] API endpoints ตอบสนองถูกต้อง
- [ ] WebSocket connections ทำงานได้
- [ ] CORS settings อนุญาต frontend access
- [ ] Error handling แสดงข้อความที่เข้าใจได้

### **📋 Features ที่ต้องทำงาน:**
- [ ] Agent login ด้วย agent code
- [ ] Get team members สำหรับ supervisor
- [ ] Send direct messages ระหว่าง supervisor และ agent  
- [ ] Send broadcast messages ถึง agents ทั้งหมด
- [ ] Real-time status updates ผ่าน WebSocket
- [ ] Message history retrieval

### **📋 Ready for Frontend Integration:**
- [ ] API documentation ชัดเจน
- [ ] Sample requests/responses พร้อม
- [ ] Error codes และ messages สม่ำเสมอ
- [ ] WebSocket events documented
- [ ] CORS configured for frontend URLs

---

## 🎯 **Next Steps**

หลังจากเข้าใจ Backend code แล้ว ขั้นตอนต่อไปคือ:

1. **🖥️ 6.6.3 Frontend Applications** - เรียนรู้การใช้ API ใน React และ Electron
2. **📅 6.2 Development Plan** - เริ่มพัฒนาตาม 14-day roadmap  
3. **🧪 6.4 Testing Strategy** - ทดสอบ integration ระหว่าง backend และ frontend

### **💡 เคล็ดลับสำหรับนักศึกษา:**
- **เริ่มจากการทำให้ทำงานได้ก่อน** แล้วค่อยปรับปรุง
- **ใช้ console.log อย่างเต็มที่** สำหรับ debugging
- **ทดสอบ API ด้วย Postman** ก่อนเชื่อมต่อ frontend
- **อ่าน error messages ให้ละเอียด** - มักจะบอกปัญหาได้ชัดเจน

**🎉 Backend Server พร้อมสำหรับการพัฒนา! ตอนนี้คุณมีพื้นฐานที่แข็งแกร่งสำหรับสร้าง Agent Wallboard System** 💪

---

## 📞 **Need Help?**

**ถ้าเจอปัญหากับ Backend:**
1. **ตรวจสอบ logs** ใน terminal ที่รัน server
2. **ดู error responses** จาก API calls
3. **ตรวจสอบ database connections** ด้วย health check endpoint
4. **ลอง restart server** หลังแก้ไขโค้ด

**Happy Backend Development! 🚀**