# 6.6.2 Backend Server Code Guide - Agent Wallboard System

## ğŸ¯ Overview

à¹€à¸­à¸à¸ªà¸²à¸£à¸™à¸µà¹‰à¸ˆà¸°à¸­à¸˜à¸´à¸šà¸²à¸¢à¹‚à¸„à¸£à¸‡à¸ªà¸£à¹‰à¸²à¸‡ Backend Server à¸‚à¸­à¸‡ Agent Wallboard System à¸—à¸µà¹ˆà¹ƒà¸Šà¹‰ **Node.js + Express + Socket.io** à¹‚à¸”à¸¢à¹€à¸™à¹‰à¸™à¸à¸²à¸£à¸­à¸˜à¸´à¸šà¸²à¸¢à¹„à¸Ÿà¸¥à¹Œà¸ªà¸³à¸„à¸±à¸à¸—à¸µà¹ˆà¸™à¸±à¸à¸¨à¸¶à¸à¸©à¸²à¸•à¹‰à¸­à¸‡à¸—à¸³à¸‡à¸²à¸™à¸”à¹‰à¸§à¸¢ à¸à¸£à¹‰à¸­à¸¡à¸•à¸±à¸§à¸­à¸¢à¹ˆà¸²à¸‡à¹‚à¸„à¹‰à¸”à¸—à¸µà¹ˆà¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¹„à¸”à¹‰à¸ˆà¸£à¸´à¸‡

### ğŸ“ à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢à¸à¸²à¸£à¹€à¸£à¸µà¸¢à¸™à¸£à¸¹à¹‰
à¹€à¸¡à¸·à¹ˆà¸­à¸ˆà¸šà¸à¸²à¸£à¸­à¹ˆà¸²à¸™à¹€à¸­à¸à¸ªà¸²à¸£à¸™à¸µà¹‰ à¸™à¸±à¸à¸¨à¸¶à¸à¸©à¸²à¸ˆà¸°à¸ªà¸²à¸¡à¸²à¸£à¸–:
- à¹€à¸‚à¹‰à¸²à¹ƒà¸ˆà¹‚à¸„à¸£à¸‡à¸ªà¸£à¹‰à¸²à¸‡ Node.js Backend à¸—à¸µà¹ˆà¸—à¸³à¸‡à¸²à¸™à¹„à¸”à¹‰à¸ˆà¸£à¸´à¸‡ 80%
- à¸£à¸¹à¹‰à¸§à¸´à¸˜à¸µà¸à¸²à¸£à¹ƒà¸Šà¹‰ API endpoints à¸—à¸µà¹ˆà¸¡à¸µà¹ƒà¸«à¹‰
- à¹€à¸‚à¹‰à¸²à¹ƒà¸ˆà¸à¸²à¸£à¸—à¸³à¸‡à¸²à¸™à¸‚à¸­à¸‡ WebSocket à¸ªà¸³à¸«à¸£à¸±à¸š real-time communication
- à¸ªà¸²à¸¡à¸²à¸£à¸–à¸›à¸£à¸±à¸šà¹à¸•à¹ˆà¸‡à¹à¸¥à¸°à¹€à¸à¸´à¹ˆà¸¡ features à¹ƒà¸«à¸¡à¹ˆà¹„à¸”à¹‰

---

## ğŸ—ï¸ **Backend Architecture Overview**

### **ğŸ“ à¹‚à¸„à¸£à¸‡à¸ªà¸£à¹‰à¸²à¸‡à¹„à¸Ÿà¸¥à¹Œà¸—à¸µà¹ˆà¸ªà¸³à¸„à¸±à¸**
```
backend-server/
â”œâ”€â”€ ğŸš€ server.js                    # Entry point - à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸—à¸¸à¸à¸­à¸¢à¹ˆà¸²à¸‡ (80% complete)
â”œâ”€â”€ âš™ï¸ config/
â”‚   â””â”€â”€ ğŸ—„ï¸ database.js             # Database connections (90% complete)
â”œâ”€â”€ ğŸ›£ï¸ routes/                      # API endpoints (85% complete)
â”‚   â”œâ”€â”€ ğŸ” auth.js                  # Login/logout APIs
â”‚   â”œâ”€â”€ ğŸ‘¥ agents.js                # Agent management APIs
â”‚   â””â”€â”€ ğŸ’¬ messages.js              # Message handling APIs
â”œâ”€â”€ ğŸ§  models/                      # Database models (90% complete)
â”‚   â”œâ”€â”€ ğŸ“„ Agent.js                 # SQLite agent model
â”‚   â””â”€â”€ ğŸ’¬ Message.js               # MongoDB message model
â”œâ”€â”€ ğŸ”Œ socket/                      # WebSocket handlers (75% complete)
â”‚   â””â”€â”€ âš¡ socketHandler.js         # Real-time event handling
â””â”€â”€ ğŸ›¡ï¸ middleware/                  # Middleware functions (95% complete)
    â””â”€â”€ ğŸ” auth.js                  # Authentication middleware
```

### **ğŸ”„ Request Flow Diagram**
```
ğŸ“± Client Request
    â†“
ğŸ›¡ï¸ CORS Middleware
    â†“
ğŸ” Authentication Middleware (à¸–à¹‰à¸²à¸•à¹‰à¸­à¸‡à¸à¸²à¸£)
    â†“
ğŸ›£ï¸ Route Handler (auth.js, agents.js, messages.js)
    â†“
ğŸ§  Database Model (Agent.js, Message.js)
    â†“
ğŸ—„ï¸ Database (SQLite/MongoDB)
    â†“
ğŸ“¨ JSON Response
```

---

## ğŸš€ **Main Server File - server.js**

### **ğŸ¯ à¸«à¸™à¹‰à¸²à¸—à¸µà¹ˆà¸«à¸¥à¸±à¸:**
- à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™ Express server
- à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸² WebSocket server
- à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­ databases
- à¸ˆà¸±à¸”à¸à¸²à¸£ middleware à¹à¸¥à¸° routes

### **ğŸ“‹ Code Walkthrough:**
```javascript
// ========== DEPENDENCIES ==========
const express = require('express');
const http = require('http');
const socketio = require('socket.io');
const cors = require('cors');
require('dotenv').config();

// ========== IMPORTS ==========
// Import route handlers
const authRoutes = require('./routes/auth');
const agentRoutes = require('./routes/agents');
const messageRoutes = require('./routes/messages');

// Import WebSocket handler
const socketHandler = require('./socket/socketHandler');

// Import database configuration
const { connectMongoDB, initSQLite } = require('./config/database');

// ========== SERVER SETUP ==========
const app = express();
const server = http.createServer(app);

// Setup Socket.io with CORS
const io = socketio(server, {
  cors: {
    origin: process.env.CORS_ORIGIN || "http://localhost:3000",
    methods: ["GET", "POST", "PUT", "DELETE"]
  }
});

// ========== MIDDLEWARE ==========
app.use(cors({
  origin: process.env.CORS_ORIGIN || "http://localhost:3000",
  credentials: true
}));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Request logging middleware (for development)
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  next();
});

// ========== API ROUTES ==========
app.use('/api/auth', authRoutes);
app.use('/api/agents', agentRoutes);
app.use('/api/messages', messageRoutes);

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    message: 'Agent Wallboard Server is running',
    timestamp: new Date().toISOString()
  });
});

// Test database endpoint
app.get('/api/test/database', async (req, res) => {
  try {
    // Test SQLite connection
    const { getSQLiteDB } = require('./config/database');
    const db = getSQLiteDB();
    
    // Test MongoDB connection
    const mongoose = require('mongoose');
    
    res.json({
      sqlite: db ? 'connected' : 'disconnected',
      mongodb: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
      sampleData: 'available'
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ========== WEBSOCKET SETUP ==========
socketHandler(io);

// ========== ERROR HANDLING ==========
app.use((err, req, res, next) => {
  console.error('Server Error:', err);
  res.status(500).json({ 
    error: 'Internal Server Error',
    message: process.env.NODE_ENV === 'development' ? err.message : 'Something went wrong'
  });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ error: 'Route not found' });
});

// ========== SERVER STARTUP ==========
async function startServer() {
  try {
    console.log('ğŸš€ Starting Agent Wallboard Server...');
    
    // Initialize databases
    console.log('ğŸ“Š Connecting to databases...');
    await initSQLite();
    await connectMongoDB();
    
    // Start server
    const PORT = process.env.PORT || 3001;
    server.listen(PORT, () => {
      console.log(`âœ… Server running on port ${PORT}`);
      console.log(`ğŸ“Š Health check: http://localhost:${PORT}/health`);
      console.log(`ğŸŒ CORS origin: ${process.env.CORS_ORIGIN || "http://localhost:3000"}`);
    });
    
  } catch (error) {
    console.error('âŒ Failed to start server:', error);
    process.exit(1);
  }
}

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('\nğŸ›‘ Shutting down server...');
  server.close(() => {
    console.log('âœ… Server closed');
    process.exit(0);
  });
});

// Start the server
startServer();

module.exports = { app, server, io };
```

### **ğŸ¯ à¸ªà¹ˆà¸§à¸™à¸—à¸µà¹ˆà¸™à¸±à¸à¸¨à¸¶à¸à¸©à¸²à¸ˆà¸°à¹à¸à¹‰à¹„à¸‚:**
- **CORS settings** - à¹€à¸à¸´à¹ˆà¸¡ domains à¸—à¸µà¹ˆà¸­à¸™à¸¸à¸à¸²à¸•
- **Middleware** - à¹€à¸à¸´à¹ˆà¸¡ logging à¸«à¸£à¸·à¸­ security middleware
- **Routes** - à¹€à¸à¸´à¹ˆà¸¡ API endpoints à¹ƒà¸«à¸¡à¹ˆ
- **Error handling** - à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡à¸à¸²à¸£à¸ˆà¸±à¸”à¸à¸²à¸£ errors

---

## ğŸ—„ï¸ **Database Configuration - config/database.js**

### **ğŸ¯ à¸«à¸™à¹‰à¸²à¸—à¸µà¹ˆà¸«à¸¥à¸±à¸:**
- à¸ˆà¸±à¸”à¸à¸²à¸£à¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­ SQLite à¹à¸¥à¸° MongoDB
- à¹ƒà¸«à¹‰ functions à¸ªà¸³à¸«à¸£à¸±à¸šà¹€à¸‚à¹‰à¸²à¸–à¸¶à¸‡ databases
- Handle connection errors

### **ğŸ“‹ Code Walkthrough:**
```javascript
// ========== DEPENDENCIES ==========
const sqlite3 = require('sqlite3').verbose();
const mongoose = require('mongoose');
const path = require('path');

let sqliteDb = null;

// ========== SQLITE CONNECTION ==========
function initSQLite() {
  return new Promise((resolve, reject) => {
    const dbPath = process.env.SQLITE_DB_PATH || path.join(__dirname, '../database/sqlite/wallboard.db');
    
    console.log(`ğŸ“Š Connecting to SQLite: ${dbPath}`);
    
    sqliteDb = new sqlite3.Database(dbPath, (err) => {
      if (err) {
        console.error('âŒ SQLite connection error:', err.message);
        reject(err);
      } else {
        console.log('âœ… Connected to SQLite database');
        resolve();
      }
    });
  });
}

// ========== MONGODB CONNECTION ==========
async function connectMongoDB() {
  try {
    const mongoUri = process.env.MONGODB_URI || 'mongodb://localhost:27017/wallboard';
    
    console.log(`ğŸƒ Connecting to MongoDB: ${mongoUri}`);
    
    await mongoose.connect(mongoUri, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      serverSelectionTimeoutMS: 5000, // 5 second timeout
    });
    
    console.log('âœ… Connected to MongoDB');
    
    // Handle MongoDB connection events
    mongoose.connection.on('error', (err) => {
      console.error('âŒ MongoDB error:', err);
    });
    
    mongoose.connection.on('disconnected', () => {
      console.log('ğŸ“´ MongoDB disconnected');
    });
    
  } catch (error) {
    console.error('âŒ MongoDB connection error:', error.message);
    throw error;
  }
}

// ========== HELPER FUNCTIONS ==========
function getSQLiteDB() {
  if (!sqliteDb) {
    throw new Error('SQLite database not initialized. Call initSQLite() first.');
  }
  return sqliteDb;
}

function closeDatabases() {
  return new Promise((resolve) => {
    // Close SQLite
    if (sqliteDb) {
      sqliteDb.close((err) => {
        if (err) console.error('Error closing SQLite:', err);
        else console.log('ğŸ“Š SQLite connection closed');
      });
    }
    
    // Close MongoDB
    mongoose.connection.close(() => {
      console.log('ğŸƒ MongoDB connection closed');
      resolve();
    });
  });
}

// ========== EXPORTS ==========
module.exports = {
  initSQLite,
  connectMongoDB,
  getSQLiteDB,
  closeDatabases
};
```

### **ğŸ¯ à¸ªà¹ˆà¸§à¸™à¸—à¸µà¹ˆà¸™à¸±à¸à¸¨à¸¶à¸à¸©à¸²à¸ˆà¸°à¹à¸à¹‰à¹„à¸‚:**
- **Database paths** - à¸›à¸£à¸±à¸š path à¹ƒà¸«à¹‰à¹€à¸«à¸¡à¸²à¸°à¸ªà¸¡
- **Connection options** - à¹€à¸à¸´à¹ˆà¸¡ timeout, retry logic
- **Error handling** - à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡à¸à¸²à¸£à¸ˆà¸±à¸”à¸à¸²à¸£ connection errors

---

## ğŸ” **Authentication Routes - routes/auth.js**

### **ğŸ¯ à¸«à¸™à¹‰à¸²à¸—à¸µà¹ˆà¸«à¸¥à¸±à¸:**
- à¸ˆà¸±à¸”à¸à¸²à¸£ agent login (à¹„à¸¡à¹ˆà¸¡à¸µ password)
- à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š agent code à¸à¸±à¸š database
- à¸ªà¹ˆà¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ agent à¸à¸¥à¸±à¸šà¹„à¸›

### **ğŸ“‹ Code Walkthrough:**
```javascript
// ========== DEPENDENCIES ==========
const express = require('express');
const { getSQLiteDB } = require('../config/database');
const router = express.Router();

// ========== LOGIN ENDPOINT ==========
router.post('/login', async (req, res) => {
  try {
    const { agentCode } = req.body;
    
    // Validate input
    if (!agentCode) {
      return res.status(400).json({ 
        error: 'Agent code is required',
        message: 'à¸à¸£à¸¸à¸“à¸²à¹ƒà¸ªà¹ˆà¸£à¸«à¸±à¸ªà¹€à¸ˆà¹‰à¸²à¸«à¸™à¹‰à¸²à¸—à¸µà¹ˆ'
      });
    }
    
    // Clean agent code (remove spaces, uppercase)
    const cleanAgentCode = agentCode.trim().toUpperCase();
    
    console.log(`ğŸ” Login attempt: ${cleanAgentCode}`);
    
    // Query database
    const db = getSQLiteDB();
    const query = `
      SELECT 
        a.agent_code,
        a.agent_name,
        a.team_id,
        a.role,
        a.email,
        a.is_active,
        t.team_name
      FROM agents a 
      LEFT JOIN teams t ON a.team_id = t.team_id 
      WHERE a.agent_code = ? AND a.is_active = 1
    `;
    
    db.get(query, [cleanAgentCode], (err, agent) => {
      if (err) {
        console.error('Database error:', err);
        return res.status(500).json({ 
          error: 'Database error',
          message: 'à¹€à¸à¸´à¸”à¸‚à¹‰à¸­à¸œà¸´à¸”à¸à¸¥à¸²à¸”à¹ƒà¸™à¸£à¸°à¸šà¸š'
        });
      }
      
      if (!agent) {
        console.log(`âŒ Agent not found: ${cleanAgentCode}`);
        return res.status(401).json({ 
          error: 'Invalid agent code',
          message: 'à¹„à¸¡à¹ˆà¸à¸šà¸£à¸«à¸±à¸ªà¹€à¸ˆà¹‰à¸²à¸«à¸™à¹‰à¸²à¸—à¸µà¹ˆà¹ƒà¸™à¸£à¸°à¸šà¸š'
        });
      }
      
      console.log(`âœ… Login successful: ${agent.agent_name}`);
      
      // Return agent data (no password needed)
      res.json({
        success: true,
        message: 'à¹€à¸‚à¹‰à¸²à¸ªà¸¹à¹ˆà¸£à¸°à¸šà¸šà¸ªà¸³à¹€à¸£à¹‡à¸ˆ',
        agent: {
          agentCode: agent.agent_code,
          agentName: agent.agent_name,
          teamId: agent.team_id,
          teamName: agent.team_name,
          role: agent.role,
          email: agent.email
        }
      });
    });
    
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ 
      error: 'Internal server error',
      message: 'à¹€à¸à¸´à¸”à¸‚à¹‰à¸­à¸œà¸´à¸”à¸à¸¥à¸²à¸”à¹ƒà¸™à¸£à¸°à¸šà¸š'
    });
  }
});

// ========== VERIFY AGENT ENDPOINT ==========
router.get('/verify/:agentCode', (req, res) => {
  try {
    const { agentCode } = req.params;
    
    if (!agentCode) {
      return res.status(400).json({ error: 'Agent code is required' });
    }
    
    const db = getSQLiteDB();
    const query = `
      SELECT agent_code, agent_name, role, is_active 
      FROM agents 
      WHERE agent_code = ?
    `;
    
    db.get(query, [agentCode.toUpperCase()], (err, agent) => {
      if (err) {
        return res.status(500).json({ error: 'Database error' });
      }
      
      res.json({
        exists: !!agent,
        active: agent ? agent.is_active === 1 : false,
        role: agent ? agent.role : null
      });
    });
    
  } catch (error) {
    console.error('Verify error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ========== GET ALL AGENTS (for testing) ==========
router.get('/agents/all', (req, res) => {
  try {
    const db = getSQLiteDB();
    const query = `
      SELECT 
        a.agent_code,
        a.agent_name,
        a.role,
        t.team_name,
        a.is_active
      FROM agents a 
      LEFT JOIN teams t ON a.team_id = t.team_id 
      ORDER BY a.role, a.agent_name
    `;
    
    db.all(query, [], (err, agents) => {
      if (err) {
        return res.status(500).json({ error: 'Database error' });
      }
      
      res.json({
        success: true,
        agents: agents,
        count: agents.length
      });
    });
    
  } catch (error) {
    console.error('Get agents error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

module.exports = router;
```

### **ğŸ§ª Testing the Auth API:**
```bash
# Test login
curl -X POST http://localhost:3001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"agentCode":"AG001"}'

# Test verify
curl http://localhost:3001/api/auth/verify/AG001

# Get all agents (for testing)
curl http://localhost:3001/api/auth/agents/all
```

### **ğŸ¯ à¸ªà¹ˆà¸§à¸™à¸—à¸µà¹ˆà¸™à¸±à¸à¸¨à¸¶à¸à¸©à¸²à¸ˆà¸°à¹à¸à¹‰à¹„à¸‚:**
- **Input validation** - à¹€à¸à¸´à¹ˆà¸¡ validation rules
- **Error messages** - à¸›à¸£à¸±à¸šà¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹ƒà¸«à¹‰à¹€à¸«à¸¡à¸²à¸°à¸ªà¸¡
- **Logging** - à¹€à¸à¸´à¹ˆà¸¡ audit logs
- **Security** - à¹€à¸à¸´à¹ˆà¸¡ rate limiting

---

## ğŸ‘¥ **Agent Routes - routes/agents.js**

### **ğŸ¯ à¸«à¸™à¹‰à¸²à¸—à¸µà¹ˆà¸«à¸¥à¸±à¸:**
- à¸ˆà¸±à¸”à¸à¸²à¸£à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ agents
- à¸­à¸±à¸›à¹€à¸”à¸• agent status
- à¸”à¸¶à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ team members

### **ğŸ“‹ Code Walkthrough:**
```javascript
// ========== DEPENDENCIES ==========
const express = require('express');
const { getSQLiteDB } = require('../config/database');
const router = express.Router();

// ========== GET TEAM AGENTS ==========
router.get('/team/:teamId', (req, res) => {
  try {
    const { teamId } = req.params;
    
    const db = getSQLiteDB();
    const query = `
      SELECT 
        a.agent_code,
        a.agent_name,
        a.role,
        a.email,
        t.team_name
      FROM agents a
      LEFT JOIN teams t ON a.team_id = t.team_id
      WHERE a.team_id = ? AND a.is_active = 1 AND a.role = 'agent'
      ORDER BY a.agent_name
    `;
    
    db.all(query, [teamId], (err, agents) => {
      if (err) {
        console.error('Database error:', err);
        return res.status(500).json({ error: 'Database error' });
      }
      
      res.json({
        success: true,
        teamId: parseInt(teamId),
        agents: agents,
        count: agents.length
      });
    });
    
  } catch (error) {
    console.error('Get team agents error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ========== GET AGENT PROFILE ==========
router.get('/profile/:agentCode', (req, res) => {
  try {
    const { agentCode } = req.params;
    
    const db = getSQLiteDB();
    const query = `
      SELECT 
        a.agent_code,
        a.agent_name,
        a.team_id,
        a.role,
        a.email,
        a.phone,
        a.hire_date,
        t.team_name,
        t.supervisor_code
      FROM agents a
      LEFT JOIN teams t ON a.team_id = t.team_id
      WHERE a.agent_code = ? AND a.is_active = 1
    `;
    
    db.get(query, [agentCode.toUpperCase()], (err, agent) => {
      if (err) {
        return res.status(500).json({ error: 'Database error' });
      }
      
      if (!agent) {
        return res.status(404).json({ error: 'Agent not found' });
      }
      
      res.json({
        success: true,
        agent: agent
      });
    });
    
  } catch (error) {
    console.error('Get agent profile error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ========== UPDATE AGENT STATUS (for future use) ==========
router.put('/status/:agentCode', (req, res) => {
  try {
    const { agentCode } = req.params;
    const { status, timestamp } = req.body;
    
    // Validate status
    const validStatuses = ['Available', 'Busy', 'Break', 'Meeting', 'Offline'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({ 
        error: 'Invalid status',
        validStatuses: validStatuses
      });
    }
    
    console.log(`ğŸ“Š Status update: ${agentCode} -> ${status}`);
    
    // For now, just acknowledge the update
    // In Week 2, students will implement MongoDB logging here
    res.json({
      success: true,
      message: 'Status updated successfully',
      agentCode: agentCode,
      status: status,
      timestamp: timestamp || new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Update status error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ========== GET ALL TEAMS ==========
router.get('/teams/all', (req, res) => {
  try {
    const db = getSQLiteDB();
    const query = `
      SELECT 
        t.team_id,
        t.team_name,
        t.supervisor_code,
        t.description,
        COUNT(a.agent_code) as agent_count
      FROM teams t
      LEFT JOIN agents a ON t.team_id = a.team_id AND a.role = 'agent' AND a.is_active = 1
      WHERE t.is_active = 1
      GROUP BY t.team_id, t.team_name, t.supervisor_code, t.description
      ORDER BY t.team_name
    `;
    
    db.all(query, [], (err, teams) => {
      if (err) {
        return res.status(500).json({ error: 'Database error' });
      }
      
      res.json({
        success: true,
        teams: teams,
        count: teams.length
      });
    });
    
  } catch (error) {
    console.error('Get teams error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

module.exports = router;
```

### **ğŸ§ª Testing the Agents API:**
```bash
# Get team agents
curl http://localhost:3001/api/agents/team/1

# Get agent profile
curl http://localhost:3001/api/agents/profile/AG001

# Update agent status
curl -X PUT http://localhost:3001/api/agents/status/AG001 \
  -H "Content-Type: application/json" \
  -d '{"status":"Break","timestamp":"2024-09-22T10:30:00Z"}'

# Get all teams
curl http://localhost:3001/api/agents/teams/all
```

---

## ğŸ’¬ **Message Routes - routes/messages.js**

### **ğŸ¯ à¸«à¸™à¹‰à¸²à¸—à¸µà¹ˆà¸«à¸¥à¸±à¸:**
- à¸ªà¹ˆà¸‡à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡ direct à¹à¸¥à¸° broadcast
- à¸šà¸±à¸™à¸—à¸¶à¸à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸¥à¸‡ MongoDB
- à¸”à¸¶à¸‡à¸›à¸£à¸°à¸§à¸±à¸•à¸´à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡

### **ğŸ“‹ Code Walkthrough:**
```javascript
// ========== DEPENDENCIES ==========
const express = require('express');
const Message = require('../models/Message'); // MongoDB model
const router = express.Router();

// ========== SEND MESSAGE ==========
router.post('/send', async (req, res) => {
  try {
    const { fromCode, toCode, message, type = 'direct', priority = 'normal' } = req.body;
    
    // Validate input
    if (!fromCode || !message) {
      return res.status(400).json({ 
        error: 'Missing required fields',
        required: ['fromCode', 'message']
      });
    }
    
    if (type === 'direct' && !toCode) {
      return res.status(400).json({ 
        error: 'toCode is required for direct messages'
      });
    }
    
    console.log(`ğŸ’¬ New ${type} message from ${fromCode}${toCode ? ` to ${toCode}` : ' (broadcast)'}`);
    
    // Create message object
    const newMessage = new Message({
      fromCode: fromCode.toUpperCase(),
      toCode: type === 'direct' ? toCode.toUpperCase() : null,
      message: message.trim(),
      type: type,
      priority: priority,
      timestamp: new Date(),
      isRead: false
    });
    
    // Save to MongoDB
    const savedMessage = await newMessage.save();
    
    res.json({
      success: true,
      message: 'Message sent successfully',
      messageId: savedMessage._id,
      data: {
        fromCode: savedMessage.fromCode,
        toCode: savedMessage.toCode,
        message: savedMessage.message,
        type: savedMessage.type,
        timestamp: savedMessage.timestamp
      }
    });
    
  } catch (error) {
    console.error('Send message error:', error);
    res.status(500).json({ 
      error: 'Failed to send message',
      details: error.message
    });
  }
});

// ========== GET MESSAGES FOR AGENT ==========
router.get('/agent/:agentCode', async (req, res) => {
  try {
    const { agentCode } = req.params;
    const { limit = 50, page = 1 } = req.query;
    
    const skip = (parseInt(page) - 1) * parseInt(limit);
    
    // Get direct messages to this agent + broadcast messages
    const messages = await Message.find({
      $or: [
        { toCode: agentCode.toUpperCase() }, // Direct messages
        { toCode: null, type: 'broadcast' }  // Broadcast messages
      ]
    })
    .sort({ timestamp: -1 })
    .limit(parseInt(limit))
    .skip(skip)
    .lean();
    
    res.json({
      success: true,
      agentCode: agentCode.toUpperCase(),
      messages: messages,
      count: messages.length,
      page: parseInt(page),
      limit: parseInt(limit)
    });
    
  } catch (error) {
    console.error('Get messages error:', error);
    res.status(500).json({ error: 'Failed to get messages' });
  }
});

// ========== MARK MESSAGE AS READ ==========
router.put('/read/:messageId', async (req, res) => {
  try {
    const { messageId } = req.params;
    const { agentCode } = req.body;
    
    const updatedMessage = await Message.findByIdAndUpdate(
      messageId,
      { 
        isRead: true, 
        readAt: new Date(),
        readBy: agentCode 
      },
      { new: true }
    );
    
    if (!updatedMessage) {
      return res.status(404).json({ error: 'Message not found' });
    }
    
    res.json({
      success: true,
      message: 'Message marked as read',
      messageId: messageId
    });
    
  } catch (error) {
    console.error('Mark read error:', error);
    res.status(500).json({ error: 'Failed to mark message as read' });
  }
});

// ========== GET MESSAGE HISTORY (for supervisors) ==========
router.get('/history/:fromCode', async (req, res) => {
  try {
    const { fromCode } = req.params;
    const { limit = 100 } = req.query;
    
    const messages = await Message.find({
      fromCode: fromCode.toUpperCase()
    })
    .sort({ timestamp: -1 })
    .limit(parseInt(limit))
    .lean();
    
    res.json({
      success: true,
      fromCode: fromCode.toUpperCase(),
      messages: messages,
      count: messages.length
    });
    
  } catch (error) {
    console.error('Get history error:', error);
    res.status(500).json({ error: 'Failed to get message history' });
  }
});

module.exports = router;
```

### **ğŸ§ª Testing the Messages API:**
```bash
# Send direct message
curl -X POST http://localhost:3001/api/messages/send \
  -H "Content-Type: application/json" \
  -d '{"fromCode":"SP001","toCode":"AG001","message":"Please update your status","type":"direct"}'

# Send broadcast message  
curl -X POST http://localhost:3001/api/messages/send \
  -H "Content-Type: application/json" \
  -d '{"fromCode":"SP001","message":"Team meeting at 2 PM","type":"broadcast","priority":"high"}'

# Get messages for agent
curl http://localhost:3001/api/messages/agent/AG001?limit=10

# Mark message as read
curl -X PUT http://localhost:3001/api/messages/read/MESSAGE_ID \
  -H "Content-Type: application/json" \
  -d '{"agentCode":"AG001"}'
```

---

## âš¡ **WebSocket Handler - socket/socketHandler.js**

### **ğŸ¯ à¸«à¸™à¹‰à¸²à¸—à¸µà¹ˆà¸«à¸¥à¸±à¸:**
- à¸ˆà¸±à¸”à¸à¸²à¸£ WebSocket connections
- Handle real-time events (status changes, messages)
- Broadcast updates à¹„à¸›à¸¢à¸±à¸‡ connected clients

### **ğŸ“‹ Code Walkthrough:**
```javascript
// ========== DEPENDENCIES ==========
const Message = require('../models/Message');

// Keep track of connected clients
const activeConnections = new Map(); // agentCode -> socketId
const supervisorConnections = new Map(); // supervisorCode -> socketId

function socketHandler(io) {
  console.log('âš¡ WebSocket server initialized');
  
  io.on('connection', (socket) => {
    console.log('ğŸ”Œ New client connected:', socket.id);
    
    // ========== AGENT CONNECTION ==========
    socket.on('agent_connect', (data) => {
      try {
        const { agentCode } = data;
        
        if (!agentCode) {
          socket.emit('connection_error', { message: 'Agent code required' });
          return;
        }
        
        const cleanAgentCode = agentCode.toUpperCase();
        
        // Store connection
        activeConnections.set(cleanAgentCode, socket.id);
        socket.agentCode = cleanAgentCode;
        socket.join(`agent_${cleanAgentCode}`);
        
        console.log(`ğŸ‘¤ Agent connected: ${cleanAgentCode}`);
        
        // Confirm connection
        socket.emit('agent_connected', {
          agentCode: cleanAgentCode,
          timestamp: new Date().toISOString()
        });
        
        // Notify supervisors about agent coming online
        socket.broadcast.emit('agent_status_change', {
          agentCode: cleanAgentCode,
          status: 'Available',
          timestamp: new Date().toISOString(),
          isOnline: true
        });
        
      } catch (error) {
        console.error('Agent connect error:', error);
        socket.emit('connection_error', { message: 'Connection failed' });
      }
    });
    
    // ========== SUPERVISOR CONNECTION ==========
    socket.on('supervisor_connect', (data) => {
      try {
        const { supervisorCode } = data;
        
        if (!supervisorCode) {
          socket.emit('connection_error', { message: 'Supervisor code required' });
          return;
        }
        
        const cleanSupervisorCode = supervisorCode.toUpperCase();
        
        // Store connection
        supervisorConnections.set(cleanSupervisorCode, socket.id);
        socket.supervisorCode = cleanSupervisorCode;
        socket.join(`supervisor_${cleanSupervisorCode}`);
        
        console.log(`ğŸ‘¨â€ğŸ’¼ Supervisor connected: ${cleanSupervisorCode}`);
        
        // Confirm connection
        socket.emit('supervisor_connected', {
          supervisorCode: cleanSupervisorCode,
          timestamp: new Date().toISOString()
        });
        
      } catch (error) {
        console.error('Supervisor connect error:', error);
        socket.emit('connection_error', { message: 'Connection failed' });
      }
    });
    
    // ========== AGENT STATUS UPDATE ==========
    socket.on('update_agent_status', (data) => {
      try {
        const { agentCode, status, timestamp } = data;
        
        if (!agentCode || !status) {
          socket.emit('status_error', { message: 'Agent code and status required' });
          return;
        }
        
        const validStatuses = ['Available', 'Busy', 'Break', 'Meeting', 'Offline'];
        if (!validStatuses.includes(status)) {
          socket.emit('status_error', { message: 'Invalid status' });
          return;
        }
        
        console.log(`ğŸ“Š Status update: ${agentCode} -> ${status}`);
        
        // Broadcast status change to all supervisors
        socket.broadcast.emit('agent_status_change', {
          agentCode: agentCode.toUpperCase(),
          status: status,
          timestamp: timestamp || new Date().toISOString(),
          isOnline: true
        });
        
        // Confirm to agent
        socket.emit('status_updated', {
          agentCode: agentCode.toUpperCase(),
          status: status,
          timestamp: timestamp || new Date().toISOString()
        });
        
        // TODO: Week 2 - Save to MongoDB here
        
      } catch (error) {
        console.error('Status update error:', error);
        socket.emit('status_error', { message: 'Failed to update status' });
      }
    });
    
    // ========== SEND DIRECT MESSAGE ==========
    socket.on('send_direct_message', async (data) => {
      try {
        const { fromCode, toCode, message, priority = 'normal' } = data;
        
        if (!fromCode || !toCode || !message) {
          socket.emit('message_error', { message: 'Missing required fields' });
          return;
        }
        
        console.log(`ğŸ’¬ Direct message: ${fromCode} -> ${toCode}`);
        
        // Save to MongoDB
        const newMessage = new Message({
          fromCode: fromCode.toUpperCase(),
          toCode: toCode.toUpperCase(),
          message: message.trim(),
          type: 'direct',
          priority: priority,
          timestamp: new Date(),
          isRead: false
        });
        
        const savedMessage = await newMessage.save();
        
        // Send to target agent
        const targetSocketId = activeConnections.get(toCode.toUpperCase());
        if (targetSocketId) {
          io.to(targetSocketId).emit('new_direct_message', {
            messageId: savedMessage._id,
            fromCode: savedMessage.fromCode,
            message: savedMessage.message,
            priority: savedMessage.priority,
            timestamp: savedMessage.timestamp
          });
        }
        
        // Confirm to sender
        socket.emit('message_sent', {
          messageId: savedMessage._id,
          toCode: savedMessage.toCode,
          timestamp: savedMessage.timestamp
        });
        
      } catch (error) {
        console.error('Direct message error:', error);
        socket.emit('message_error', { message: 'Failed to send message' });
      }
    });
    
    // ========== SEND BROADCAST MESSAGE ==========
    socket.on('send_broadcast_message', async (data) => {
      try {
        const { fromCode, message, priority = 'normal' } = data;
        
        if (!fromCode || !message) {
          socket.emit('message_error', { message: 'Missing required fields' });
          return;
        }
        
        console.log(`ğŸ“¢ Broadcast message from: ${fromCode}`);
        
        // Save to MongoDB
        const newMessage = new Message({
          fromCode: fromCode.toUpperCase(),
          toCode: null, // null for broadcast
          message: message.trim(),
          type: 'broadcast',
          priority: priority,
          timestamp: new Date(),
          isRead: false
        });
        
        const savedMessage = await newMessage.save();
        
        // Broadcast to all connected agents
        socket.broadcast.emit('new_broadcast_message', {
          messageId: savedMessage._id,
          fromCode: savedMessage.fromCode,
          message: savedMessage.message,
          priority: savedMessage.priority,
          timestamp: savedMessage.timestamp
        });
        
        // Confirm to sender
        socket.emit('broadcast_sent', {
          messageId: savedMessage._id,
          timestamp: savedMessage.timestamp,
          recipientCount: activeConnections.size
        });
        
      } catch (error) {
        console.error('Broadcast message error:', error);
        socket.emit('message_error', { message: 'Failed to send broadcast' });
      }
    });
    
    // ========== GET CONNECTED AGENTS ==========
    socket.on('get_connected_agents', () => {
      try {
        const connectedAgents = Array.from(activeConnections.keys());
        
        socket.emit('connected_agents_list', {
          agents: connectedAgents,
          count: connectedAgents.length,
          timestamp: new Date().toISOString()
        });
        
      } catch (error) {
        console.error('Get connected agents error:', error);
        socket.emit('connection_error', { message: 'Failed to get agent list' });
      }
    });
    
    // ========== DISCONNECT HANDLING ==========
    socket.on('disconnect', (reason) => {
      console.log(`ğŸ‘‹ Client disconnected: ${socket.id}, reason: ${reason}`);
      
      try {
        // Remove from agent connections
        if (socket.agentCode) {
          activeConnections.delete(socket.agentCode);
          
          // Notify supervisors that agent went offline
          socket.broadcast.emit('agent_status_change', {
            agentCode: socket.agentCode,
            status: 'Offline',
            timestamp: new Date().toISOString(),
            isOnline: false
          });
          
          console.log(`ğŸ‘¤ Agent disconnected: ${socket.agentCode}`);
        }
        
        // Remove from supervisor connections
        if (socket.supervisorCode) {
          supervisorConnections.delete(socket.supervisorCode);
          console.log(`ğŸ‘¨â€ğŸ’¼ Supervisor disconnected: ${socket.supervisorCode}`);
        }
        
      } catch (error) {
        console.error('Disconnect handling error:', error);
      }
    });
    
    // ========== PING/PONG FOR CONNECTION HEALTH ==========
    socket.on('ping', () => {
      socket.emit('pong', { timestamp: new Date().toISOString() });
    });
    
  });
  
  // ========== PERIODIC CONNECTION STATUS ==========
  setInterval(() => {
    const stats = {
      connectedAgents: activeConnections.size,
      connectedSupervisors: supervisorConnections.size,
      totalConnections: io.engine.clientsCount,
      timestamp: new Date().toISOString()
    };
    
    console.log(`ğŸ“Š Connection stats:`, stats);
    
    // Broadcast stats to supervisors
    io.emit('connection_stats', stats);
  }, 30000); // Every 30 seconds
}

module.exports = socketHandler;
```

### **ğŸ§ª Testing WebSocket Events:**
```javascript
// Test WebSocket connection (in browser console or test file)
const socket = io('http://localhost:3001');

// Agent connection
socket.emit('agent_connect', { agentCode: 'AG001' });

// Status update
socket.emit('update_agent_status', { 
  agentCode: 'AG001', 
  status: 'Break' 
});

// Send direct message
socket.emit('send_direct_message', {
  fromCode: 'SP001',
  toCode: 'AG001', 
  message: 'Please update your status'
});

// Listen for events
socket.on('agent_connected', (data) => console.log('Connected:', data));
socket.on('new_direct_message', (data) => console.log('New message:', data));
socket.on('agent_status_change', (data) => console.log('Status change:', data));
```

---

## ğŸ§  **Database Models**

### **ğŸ“„ SQLite Model - models/Agent.js**
```javascript
// ========== DEPENDENCIES ==========
const { getSQLiteDB } = require('../config/database');

class Agent {
  // ========== FIND AGENT BY CODE ==========
  static async findByCode(agentCode) {
    return new Promise((resolve, reject) => {
      const db = getSQLiteDB();
      const query = `
        SELECT a.*, t.team_name 
        FROM agents a 
        LEFT JOIN teams t ON a.team_id = t.team_id 
        WHERE a.agent_code = ? AND a.is_active = 1
      `;
      
      db.get(query, [agentCode], (err, row) => {
        if (err) {
          reject(err);
        } else {
          resolve(row);
        }
      });
    });
  }
  
  // ========== FIND AGENTS BY TEAM ==========
  static async findByTeam(teamId) {
    return new Promise((resolve, reject) => {
      const db = getSQLiteDB();
      const query = `
        SELECT agent_code, agent_name, role, email
        FROM agents 
        WHERE team_id = ? AND is_active = 1 AND role = 'agent'
        ORDER BY agent_name
      `;
      
      db.all(query, [teamId], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows);
        }
      });
    });
  }
  
  // ========== GET ALL SUPERVISORS ==========
  static async getAllSupervisors() {
    return new Promise((resolve, reject) => {
      const db = getSQLiteDB();
      const query = `
        SELECT a.*, t.team_name
        FROM agents a
        LEFT JOIN teams t ON a.team_id = t.team_id
        WHERE a.role = 'supervisor' AND a.is_active = 1
        ORDER BY a.agent_name
      `;
      
      db.all(query, [], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows);
        }
      });
    });
  }
}

module.exports = Agent;
```

### **ğŸ’¬ MongoDB Model - models/Message.js**
```javascript
// ========== DEPENDENCIES ==========
const mongoose = require('mongoose');

// ========== MESSAGE SCHEMA ==========
const messageSchema = new mongoose.Schema({
  fromCode: {
    type: String,
    required: true,
    index: true,
    uppercase: true
  },
  toCode: {
    type: String,
    index: true,
    uppercase: true,
    default: null // null for broadcast messages
  },
  message: {
    type: String,
    required: true,
    maxlength: 1000,
    trim: true
  },
  type: {
    type: String,
    enum: ['direct', 'broadcast'],
    default: 'direct'
  },
  priority: {
    type: String,
    enum: ['low', 'normal', 'high', 'urgent'],
    default: 'normal'
  },
  timestamp: {
    type: Date,
    default: Date.now,
    index: true
  },
  isRead: {
    type: Boolean,
    default: false
  },
  readAt: {
    type: Date,
    default: null
  },
  readBy: {
    type: String,
    default: null
  }
}, {
  collection: 'messages',
  timestamps: true // adds createdAt and updatedAt
});

// ========== INDEXES FOR PERFORMANCE ==========
messageSchema.index({ toCode: 1, timestamp: -1 });
messageSchema.index({ fromCode: 1, timestamp: -1 });
messageSchema.index({ type: 1, timestamp: -1 });

// ========== STATIC METHODS ==========
messageSchema.statics.getMessagesForAgent = function(agentCode, limit = 50) {
  return this.find({
    $or: [
      { toCode: agentCode },
      { toCode: null, type: 'broadcast' }
    ]
  })
  .sort({ timestamp: -1 })
  .limit(limit)
  .lean();
};

messageSchema.statics.getMessageHistory = function(fromCode, limit = 100) {
  return this.find({ fromCode: fromCode })
    .sort({ timestamp: -1 })
    .limit(limit)
    .lean();
};

// ========== CREATE MODEL ==========
const Message = mongoose.model('Message', messageSchema);

module.exports = Message;
```

---

## ğŸ¯ **à¸ªà¸´à¹ˆà¸‡à¸—à¸µà¹ˆà¸™à¸±à¸à¸¨à¸¶à¸à¸©à¸²à¸ˆà¸°à¸—à¸³à¹ƒà¸™ 2 à¸ªà¸±à¸›à¸”à¸²à¸«à¹Œ**

### **âœ… Week 1: à¹€à¸‚à¹‰à¸²à¹ƒà¸ˆà¹à¸¥à¸°à¸›à¸£à¸±à¸šà¹à¸•à¹ˆà¸‡ (à¸‡à¸²à¸™à¸‡à¹ˆà¸²à¸¢ 70%)**
```
ğŸ“‹ Day 1-2: à¸—à¸³à¸„à¸§à¸²à¸¡à¹€à¸‚à¹‰à¸²à¹ƒà¸ˆà¹‚à¸„à¹‰à¸”
â”œâ”€â”€ à¸£à¸±à¸™ backend server à¹ƒà¸«à¹‰à¹„à¸”à¹‰
â”œâ”€â”€ à¸—à¸”à¸ªà¸­à¸š API endpoints à¸”à¹‰à¸§à¸¢ Postman
â”œâ”€â”€ à¹€à¸‚à¹‰à¸²à¹ƒà¸ˆ WebSocket events
â””â”€â”€ à¸—à¸”à¸ªà¸­à¸šà¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­ database

ğŸ“‹ Day 3-4: à¸›à¸£à¸±à¸šà¹à¸•à¹ˆà¸‡à¸à¸·à¹‰à¸™à¸à¸²à¸™
â”œâ”€â”€ à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™ error messages à¹€à¸›à¹‡à¸™à¸ à¸²à¸©à¸²à¹„à¸—à¸¢
â”œâ”€â”€ à¹€à¸à¸´à¹ˆà¸¡ console.log à¸ªà¸³à¸«à¸£à¸±à¸š debugging
â”œâ”€â”€ à¸›à¸£à¸±à¸šà¹à¸•à¹ˆà¸‡ CORS settings
â””â”€â”€ à¹€à¸à¸´à¹ˆà¸¡ input validation

ğŸ“‹ Day 5-7: à¸—à¸”à¸ªà¸­à¸š Integration
â”œâ”€â”€ à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¸à¸±à¸š frontend applications
â”œâ”€â”€ à¸—à¸”à¸ªà¸­à¸š real-time features
â”œâ”€â”€ à¹à¸à¹‰à¹„à¸‚ bugs à¸—à¸µà¹ˆà¹€à¸ˆà¸­
â””â”€â”€ à¹€à¸‚à¸µà¸¢à¸™ documentation à¸à¸·à¹‰à¸™à¸à¸²à¸™
```

### **ğŸš€ Week 2: à¹€à¸à¸´à¹ˆà¸¡à¸Ÿà¸µà¹€à¸ˆà¸­à¸£à¹Œà¹ƒà¸«à¸¡à¹ˆ (à¸‡à¸²à¸™à¸—à¹‰à¸²à¸—à¸²à¸¢ 30%)**
```
ğŸ“‹ Advanced Features:
â”œâ”€â”€ à¹€à¸à¸´à¹ˆà¸¡ API endpoint à¸ªà¸³à¸«à¸£à¸±à¸š team statistics
â”œâ”€â”€ à¹€à¸à¸´à¹ˆà¸¡ message templates à¹ƒà¸™ database
â”œâ”€â”€ à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡ WebSocket error handling  
â”œâ”€â”€ à¹€à¸à¸´à¹ˆà¸¡ rate limiting à¸ªà¸³à¸«à¸£à¸±à¸š API
â””â”€â”€ à¹€à¸à¸´à¹ˆà¸¡ basic logging system

ğŸ“‹ Integration & Testing:
â”œâ”€â”€ Integration testing à¸à¸±à¸š frontend
â”œâ”€â”€ Performance testing à¸à¸±à¸šà¸«à¸¥à¸²à¸¢ à¹† users
â”œâ”€â”€ Error scenarios testing
â””â”€â”€ Documentation à¸—à¸µà¹ˆà¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œ
```

---

## ğŸ§ª **Complete API Testing Guide**

### **ğŸ“‹ Postman Collection à¸ªà¸³à¸«à¸£à¸±à¸šà¸—à¸”à¸ªà¸­à¸š:**
```javascript
// Import à¸¥à¸‡à¹ƒà¸™ Postman
{
  "name": "Agent Wallboard API",
  "requests": [
    {
      "name": "Health Check",
      "method": "GET",
      "url": "http://localhost:3001/health"
    },
    {
      "name": "Agent Login",
      "method": "POST", 
      "url": "http://localhost:3001/api/auth/login",
      "body": {
        "agentCode": "AG001"
      }
    },
    {
      "name": "Get Team Agents",
      "method": "GET",
      "url": "http://localhost:3001/api/agents/team/1"
    },
    {
      "name": "Send Direct Message",
      "method": "POST",
      "url": "http://localhost:3001/api/messages/send",
      "body": {
        "fromCode": "SP001",
        "toCode": "AG001", 
        "message": "Please update your status",
        "type": "direct"
      }
    }
  ]
}
```

### **ğŸ”§ Development Scripts:**
```bash
# Start development server with auto-restart
npm run dev

# Test all API endpoints
npm run test:api

# Check database connections  
npm run test:db

# Run with debug logging
DEBUG=* npm run dev
```

---

## âœ… **Backend Completion Checklist**

### **ğŸ“‹ à¸à¸·à¹‰à¸™à¸à¸²à¸™à¸—à¸µà¹ˆà¸•à¹‰à¸­à¸‡à¸—à¸³à¸‡à¸²à¸™à¹„à¸”à¹‰:**
- [ ] Server à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¹„à¸”à¹‰à¹‚à¸”à¸¢à¹„à¸¡à¹ˆà¸¡à¸µ errors
- [ ] à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­ SQLite à¹à¸¥à¸° MongoDB à¸ªà¸³à¹€à¸£à¹‡à¸ˆ
- [ ] API endpoints à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸–à¸¹à¸à¸•à¹‰à¸­à¸‡
- [ ] WebSocket connections à¸—à¸³à¸‡à¸²à¸™à¹„à¸”à¹‰
- [ ] CORS settings à¸­à¸™à¸¸à¸à¸²à¸• frontend access
- [ ] Error handling à¹à¸ªà¸”à¸‡à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸—à¸µà¹ˆà¹€à¸‚à¹‰à¸²à¹ƒà¸ˆà¹„à¸”à¹‰

### **ğŸ“‹ Features à¸—à¸µà¹ˆà¸•à¹‰à¸­à¸‡à¸—à¸³à¸‡à¸²à¸™:**
- [ ] Agent login à¸”à¹‰à¸§à¸¢ agent code
- [ ] Get team members à¸ªà¸³à¸«à¸£à¸±à¸š supervisor
- [ ] Send direct messages à¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡ supervisor à¹à¸¥à¸° agent  
- [ ] Send broadcast messages à¸–à¸¶à¸‡ agents à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”
- [ ] Real-time status updates à¸œà¹ˆà¸²à¸™ WebSocket
- [ ] Message history retrieval

### **ğŸ“‹ Ready for Frontend Integration:**
- [ ] API documentation à¸Šà¸±à¸”à¹€à¸ˆà¸™
- [ ] Sample requests/responses à¸à¸£à¹‰à¸­à¸¡
- [ ] Error codes à¹à¸¥à¸° messages à¸ªà¸¡à¹ˆà¸³à¹€à¸ªà¸¡à¸­
- [ ] WebSocket events documented
- [ ] CORS configured for frontend URLs

---

## ğŸ¯ **Next Steps**

à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸à¹€à¸‚à¹‰à¸²à¹ƒà¸ˆ Backend code à¹à¸¥à¹‰à¸§ à¸‚à¸±à¹‰à¸™à¸•à¸­à¸™à¸•à¹ˆà¸­à¹„à¸›à¸„à¸·à¸­:

1. **ğŸ–¥ï¸ 6.6.3 Frontend Applications** - à¹€à¸£à¸µà¸¢à¸™à¸£à¸¹à¹‰à¸à¸²à¸£à¹ƒà¸Šà¹‰ API à¹ƒà¸™ React à¹à¸¥à¸° Electron
2. **ğŸ“… 6.2 Development Plan** - à¹€à¸£à¸´à¹ˆà¸¡à¸à¸±à¸’à¸™à¸²à¸•à¸²à¸¡ 14-day roadmap  
3. **ğŸ§ª 6.4 Testing Strategy** - à¸—à¸”à¸ªà¸­à¸š integration à¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡ backend à¹à¸¥à¸° frontend

### **ğŸ’¡ à¹€à¸„à¸¥à¹‡à¸”à¸¥à¸±à¸šà¸ªà¸³à¸«à¸£à¸±à¸šà¸™à¸±à¸à¸¨à¸¶à¸à¸©à¸²:**
- **à¹€à¸£à¸´à¹ˆà¸¡à¸ˆà¸²à¸à¸à¸²à¸£à¸—à¸³à¹ƒà¸«à¹‰à¸—à¸³à¸‡à¸²à¸™à¹„à¸”à¹‰à¸à¹ˆà¸­à¸™** à¹à¸¥à¹‰à¸§à¸„à¹ˆà¸­à¸¢à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡
- **à¹ƒà¸Šà¹‰ console.log à¸­à¸¢à¹ˆà¸²à¸‡à¹€à¸•à¹‡à¸¡à¸—à¸µà¹ˆ** à¸ªà¸³à¸«à¸£à¸±à¸š debugging
- **à¸—à¸”à¸ªà¸­à¸š API à¸”à¹‰à¸§à¸¢ Postman** à¸à¹ˆà¸­à¸™à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­ frontend
- **à¸­à¹ˆà¸²à¸™ error messages à¹ƒà¸«à¹‰à¸¥à¸°à¹€à¸­à¸µà¸¢à¸”** - à¸¡à¸±à¸à¸ˆà¸°à¸šà¸­à¸à¸›à¸±à¸à¸«à¸²à¹„à¸”à¹‰à¸Šà¸±à¸”à¹€à¸ˆà¸™

**ğŸ‰ Backend Server à¸à¸£à¹‰à¸­à¸¡à¸ªà¸³à¸«à¸£à¸±à¸šà¸à¸²à¸£à¸à¸±à¸’à¸™à¸²! à¸•à¸­à¸™à¸™à¸µà¹‰à¸„à¸¸à¸“à¸¡à¸µà¸à¸·à¹‰à¸™à¸à¸²à¸™à¸—à¸µà¹ˆà¹à¸‚à¹‡à¸‡à¹à¸à¸£à¹ˆà¸‡à¸ªà¸³à¸«à¸£à¸±à¸šà¸ªà¸£à¹‰à¸²à¸‡ Agent Wallboard System** ğŸ’ª

---

## ğŸ“ **Need Help?**

**à¸–à¹‰à¸²à¹€à¸ˆà¸­à¸›à¸±à¸à¸«à¸²à¸à¸±à¸š Backend:**
1. **à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š logs** à¹ƒà¸™ terminal à¸—à¸µà¹ˆà¸£à¸±à¸™ server
2. **à¸”à¸¹ error responses** à¸ˆà¸²à¸ API calls
3. **à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š database connections** à¸”à¹‰à¸§à¸¢ health check endpoint
4. **à¸¥à¸­à¸‡ restart server** à¸«à¸¥à¸±à¸‡à¹à¸à¹‰à¹„à¸‚à¹‚à¸„à¹‰à¸”

**Happy Backend Development! ğŸš€**