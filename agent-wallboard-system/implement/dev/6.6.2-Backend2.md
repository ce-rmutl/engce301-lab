# 6.6.2 Backend Server Code Guide - Agent Wallboard System

## 🎯 ภาพรวม

เอกสารนี้จะอธิบายโครงสร้าง Backend Server ของ Agent Wallboard System ที่ใช้ **Node.js + Express + Socket.io** โดยเน้นการอธิบายไฟล์สำคัญที่นักศึกษาต้องทำงานด้วย พร้อมตัวอย่างโค้ดที่ใช้งานได้จริง

### 🎓 เป้าหมายการเรียนรู้
เมื่อจบการอ่านเอกสารนี้ นักศึกษาจะสามารถ:
- เข้าใจโครงสร้าง Node.js Backend ที่ทำงานได้จริง 85%
- รู้วิธีการใช้ API endpoints ที่มีให้
- เข้าใจการทำงานของ WebSocket สำหรับ real-time communication
- สามารถปรับแต่งและเพิ่ม features ใหม่ได้

---

## 🏗️ **Backend Architecture Overview**

### **📁 โครงสร้างไฟล์ที่สำคัญ**
```
backend-server/
├── 🚀 server.js                    # Entry point - เริ่มต้นทุกอย่าง (85% complete)
├── 📦 package.json                 # Dependencies และ scripts
├── 🔧 .env.example                 # Environment variables template
│
├── ⚙️ config/
│   └── 🗄️ database.js             # Database connections (90% complete)
│
├── 🛣️ routes/                      # API endpoints (85% complete)
│   ├── 🔐 auth.js                  # Authentication APIs
│   ├── 👥 agents.js                # Agent management APIs
│   └── 💬 messages.js              # Message handling APIs
│
├── 🧠 models/                      # Database models (90% complete)
│   ├── 📄 Agent.js                 # SQLite agent model
│   ├── 💬 Message.js               # MongoDB message model
│   └── 📊 Status.js                # MongoDB status model
│
├── 🔌 socket/                      # WebSocket handlers (75% complete)
│   ├── ⚡ socketHandler.js         # Main WebSocket event handling
│   ├── 📡 statusEvents.js          # Status change events
│   └── 💬 messageEvents.js         # Message sending/receiving events
│
├── 🛡️ middleware/                  # Middleware functions (95% complete)
│   ├── 🔐 auth.js                  # JWT authentication middleware
│   ├── 🌐 cors.js                  # CORS configuration
│   └── ❌ errorHandler.js          # Error handling middleware
│
└── 🧪 test/                        # Basic API tests (optional)
    ├── 🔐 auth.test.js             # Authentication tests
    └── 💬 messages.test.js         # Message API tests
```

### **🔄 Request Flow Diagram**
```
📱 Client Request
    ↓
🛡️ CORS Middleware
    ↓
🔐 Authentication Middleware (ถ้าต้องการ)
    ↓
🛣️ Route Handler (auth.js, agents.js, messages.js)
    ↓
🧠 Database Model (Agent.js, Message.js)
    ↓
🗄️ Database (SQLite/MongoDB)
    ↓
📨 JSON Response
```

---

## 🚀 **Main Server File - server.js**

### **🎯 หน้าที่หลัก:**
- เริ่มต้น Express server
- ตั้งค่า WebSocket server
- เชื่อมต่อ databases
- จัดการ middleware และ routes

### **📋 Code Walkthrough:**
```javascript
// ========== DEPENDENCIES ==========
const express = require('express');
const http = require('http');
const socketio = require('socket.io');
const cors = require('cors');
require('dotenv').config();

// ========== IMPORTS ==========
// Import route handlers
const authRoutes = require('./routes/auth');
const agentRoutes = require('./routes/agents');
const messageRoutes = require('./routes/messages');

// Import WebSocket handler
const socketHandler = require('./socket/socketHandler');

// Import database configuration
const { connectMongoDB, initSQLite } = require('./config/database');

// ========== EXPRESS APP SETUP ==========
const app = express();
const server = http.createServer(app);

// ========== MIDDLEWARE SETUP ==========
app.use(cors({
  origin: ['http://localhost:3000', 'http://localhost:3001'],
  credentials: true
}));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// ========== ROUTES SETUP ==========
app.use('/api/auth', authRoutes);
app.use('/api/agents', agentRoutes);
app.use('/api/messages', messageRoutes);

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

// ========== WEBSOCKET SETUP ==========
const io = socketio(server, {
  cors: {
    origin: ['http://localhost:3000', 'http://localhost:3001'],
    methods: ['GET', 'POST']
  }
});

// Initialize WebSocket handler
socketHandler(io);

// ========== DATABASE INITIALIZATION ==========
async function initializeDatabases() {
  try {
    await initSQLite();
    console.log('✅ SQLite database initialized');
    
    await connectMongoDB();
    console.log('✅ MongoDB connected');
  } catch (error) {
    console.error('❌ Database initialization failed:', error);
    process.exit(1);
  }
}

// ========== SERVER START ==========
const PORT = process.env.PORT || 3001;

initializeDatabases().then(() => {
  server.listen(PORT, () => {
    console.log(`🚀 Backend server running on port ${PORT}`);
    console.log(`📊 Health check: http://localhost:${PORT}/health`);
    console.log(`⚡ WebSocket server ready`);
  });
});

module.exports = app;
```

---

## 🛣️ **API Routes Structure**

### **🔐 Authentication Routes - routes/auth.js**

**🎯 หน้าที่:** จัดการการ login/logout และ authentication

```javascript
const express = require('express');
const jwt = require('jsonwebtoken');
const router = express.Router();
const Agent = require('../models/Agent');

// ========== AGENT/SUPERVISOR LOGIN ==========
router.post('/login', async (req, res) => {
  try {
    const { agentCode, supervisorCode, type } = req.body;
    
    // Determine login type
    const isAgent = agentCode && !supervisorCode;
    const isSupervisor = supervisorCode && !agentCode;
    
    if (!isAgent && !isSupervisor) {
      return res.status(400).json({
        success: false,
        error: 'Must provide either agentCode or supervisorCode'
      });
    }
    
    let user;
    
    if (isAgent) {
      // Agent login
      user = await Agent.findByCode(agentCode.toUpperCase());
      if (!user || user.role !== 'agent') {
        return res.status(401).json({
          success: false,
          error: 'Invalid agent code'
        });
      }
    } else {
      // Supervisor login
      user = await Agent.findByCode(supervisorCode.toUpperCase());
      if (!user || user.role !== 'supervisor') {
        return res.status(401).json({
          success: false,
          error: 'Invalid supervisor code'
        });
      }
      
      // Get team data for supervisor
      const teamData = await Agent.findByTeam(user.teamId);
      user.teamData = teamData;
    }
    
    // Generate JWT token
    const token = jwt.sign(
      { 
        userId: user.agentCode,
        role: user.role,
        teamId: user.teamId 
      },
      process.env.JWT_SECRET || 'default-secret',
      { expiresIn: '24h' }
    );
    
    res.json({
      success: true,
      data: {
        user: {
          agentCode: user.agentCode,
          agentName: user.agentName,
          teamId: user.teamId,
          teamName: user.teamName,
          role: user.role,
          ...(user.teamData && { teamData: user.teamData })
        },
        token
      }
    });
    
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});

// ========== LOGOUT ==========
router.post('/logout', (req, res) => {
  // In a real app, you might invalidate the JWT token here
  res.json({
    success: true,
    message: 'Logged out successfully'
  });
});

module.exports = router;
```

### **👥 Agent Management Routes - routes/agents.js**

**🎯 หน้าที่:** จัดการข้อมูล agents และ status updates

```javascript
const express = require('express');
const router = express.Router();
const Agent = require('../models/Agent');
const Status = require('../models/Status');
const authMiddleware = require('../middleware/auth');

// ========== GET TEAM AGENTS (for supervisors) ==========
router.get('/team/:teamId', authMiddleware, async (req, res) => {
  try {
    const { teamId } = req.params;
    
    const agents = await Agent.findByTeam(parseInt(teamId));
    
    res.json({
      success: true,
      teamId: parseInt(teamId),
      agents: agents,
      count: agents.length
    });
    
  } catch (error) {
    console.error('Get team agents error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get team agents'
    });
  }
});

// ========== UPDATE AGENT STATUS ==========
router.put('/:agentCode/status', authMiddleware, async (req, res) => {
  try {
    const { agentCode } = req.params;
    const { status } = req.body;
    
    // Validate status
    const validStatuses = ['Available', 'Busy', 'Break', 'Offline'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({
        success: false,
        error: 'Invalid status. Must be: ' + validStatuses.join(', ')
      });
    }
    
    // Verify agent exists
    const agent = await Agent.findByCode(agentCode.toUpperCase());
    if (!agent) {
      return res.status(404).json({
        success: false,
        error: 'Agent not found'
      });
    }
    
    // Save status to MongoDB
    const statusUpdate = await Status.create({
      agentCode: agentCode.toUpperCase(),
      status: status,
      timestamp: new Date(),
      teamId: agent.teamId
    });
    
    res.json({
      success: true,
      data: {
        agentCode: agentCode.toUpperCase(),
        currentStatus: status,
        timestamp: statusUpdate.timestamp,
        teamId: agent.teamId
      }
    });
    
  } catch (error) {
    console.error('Update status error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update status'
    });
  }
});

// ========== GET AGENT HISTORY ==========
router.get('/:agentCode/history', authMiddleware, async (req, res) => {
  try {
    const { agentCode } = req.params;
    const { limit = 50 } = req.query;
    
    const history = await Status.find({ 
      agentCode: agentCode.toUpperCase() 
    })
    .sort({ timestamp: -1 })
    .limit(parseInt(limit))
    .lean();
    
    res.json({
      success: true,
      agentCode: agentCode.toUpperCase(),
      history: history,
      count: history.length
    });
    
  } catch (error) {
    console.error('Get agent history error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get agent history'
    });
  }
});

module.exports = router;
```

### **💬 Message Routes - routes/messages.js**

**🎯 หน้าที่:** จัดการการส่งและรับข้อความ

```javascript
const express = require('express');
const router = express.Router();
const Message = require('../models/Message');
const Agent = require('../models/Agent');
const authMiddleware = require('../middleware/auth');

// ========== SEND MESSAGE ==========
router.post('/send', authMiddleware, async (req, res) => {
  try {
    const { fromCode, toCode, toTeamId, content, type, priority } = req.body;
    
    // Validate required fields
    if (!fromCode || !content || !type) {
      return res.status(400).json({
        success: false,
        error: 'fromCode, content, and type are required'
      });
    }
    
    // Validate message type
    if (!['direct', 'broadcast'].includes(type)) {
      return res.status(400).json({
        success: false,
        error: 'type must be either "direct" or "broadcast"'
      });
    }
    
    // For direct messages, validate recipient
    if (type === 'direct' && !toCode) {
      return res.status(400).json({
        success: false,
        error: 'toCode is required for direct messages'
      });
    }
    
    // For broadcast messages, validate team
    if (type === 'broadcast' && !toTeamId) {
      return res.status(400).json({
        success: false,
        error: 'toTeamId is required for broadcast messages'
      });
    }
    
    // Create message
    const messageData = {
      fromCode: fromCode.toUpperCase(),
      content: content,
      type: type,
      priority: priority || 'normal',
      timestamp: new Date(),
      isRead: false
    };
    
    if (type === 'direct') {
      messageData.toCode = toCode.toUpperCase();
    } else {
      messageData.toTeamId = parseInt(toTeamId);
    }
    
    const message = await Message.create(messageData);
    
    res.json({
      success: true,
      data: {
        messageId: message._id,
        fromCode: message.fromCode,
        type: message.type,
        timestamp: message.timestamp,
        ...(message.toCode && { toCode: message.toCode }),
        ...(message.toTeamId && { toTeamId: message.toTeamId })
      }
    });
    
  } catch (error) {
    console.error('Send message error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to send message'
    });
  }
});

// ========== GET MESSAGES FOR AGENT ==========
router.get('/agent/:agentCode', authMiddleware, async (req, res) => {
  try {
    const { agentCode } = req.params;
    const { limit = 50, unreadOnly = false } = req.query;
    
    // Get agent info for team
    const agent = await Agent.findByCode(agentCode.toUpperCase());
    if (!agent) {
      return res.status(404).json({
        success: false,
        error: 'Agent not found'
      });
    }
    
    // Build query
    const query = {
      $or: [
        { toCode: agentCode.toUpperCase() }, // Direct messages
        { toTeamId: agent.teamId }           // Broadcast messages
      ]
    };
    
    if (unreadOnly === 'true') {
      query.isRead = false;
    }
    
    const messages = await Message.find(query)
      .sort({ timestamp: -1 })
      .limit(parseInt(limit))
      .lean();
    
    res.json({
      success: true,
      agentCode: agentCode.toUpperCase(),
      messages: messages,
      count: messages.length
    });
    
  } catch (error) {
    console.error('Get agent messages error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get messages'
    });
  }
});

// ========== MARK MESSAGE AS READ ==========
router.put('/:messageId/read', authMiddleware, async (req, res) => {
  try {
    const { messageId } = req.params;
    
    const message = await Message.findByIdAndUpdate(
      messageId,
      { isRead: true, readAt: new Date() },
      { new: true }
    );
    
    if (!message) {
      return res.status(404).json({
        success: false,
        error: 'Message not found'
      });
    }
    
    res.json({
      success: true,
      data: {
        messageId: message._id,
        isRead: message.isRead,
        readAt: message.readAt
      }
    });
    
  } catch (error) {
    console.error('Mark message read error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to mark message as read'
    });
  }
});

// ========== GET MESSAGE HISTORY (for supervisors) ==========
router.get('/history/:fromCode', authMiddleware, async (req, res) => {
  try {
    const { fromCode } = req.params;
    const { limit = 100 } = req.query;
    
    const messages = await Message.find({
      fromCode: fromCode.toUpperCase()
    })
    .sort({ timestamp: -1 })
    .limit(parseInt(limit))
    .lean();
    
    res.json({
      success: true,
      fromCode: fromCode.toUpperCase(),
      messages: messages,
      count: messages.length
    });
    
  } catch (error) {
    console.error('Get history error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get message history'
    });
  }
});

module.exports = router;
```

---

## ⚡ **WebSocket Handler - socket/socketHandler.js**

### **🎯 หน้าที่หลัก:**
- จัดการ WebSocket connections
- Handle real-time events (status changes, messages)
- Broadcast updates ไปยัง connected clients

### **📋 Code Walkthrough:**
```javascript
const Message = require('../models/Message');
const Status = require('../models/Status');

// Keep track of connected clients
const activeConnections = new Map(); // agentCode -> socketId
const supervisorConnections = new Map(); // supervisorCode -> socketId

function socketHandler(io) {
  console.log('⚡ WebSocket server initialized');
  
  io.on('connection', (socket) => {
    console.log('🔌 New client connected:', socket.id);
    
    // ========== AGENT CONNECTION ==========
    socket.on('agent_connect', (data) => {
      try {
        const { agentCode } = data;
        
        if (!agentCode) {
          socket.emit('connection_error', { message: 'Agent code required' });
          return;
        }
        
        const cleanAgentCode = agentCode.toUpperCase();
        
        // Store connection
        activeConnections.set(cleanAgentCode, socket.id);
        socket.agentCode = cleanAgentCode;
        socket.userType = 'agent';
        
        console.log(`👤 Agent ${cleanAgentCode} connected`);
        
        // Notify supervisors that agent is online
        socket.broadcast.emit('agent_connected', {
          agentCode: cleanAgentCode,
          timestamp: new Date()
        });
        
        socket.emit('connection_success', {
          agentCode: cleanAgentCode,
          status: 'connected'
        });
        
      } catch (error) {
        console.error('Agent connect error:', error);
        socket.emit('connection_error', { message: 'Connection failed' });
      }
    });
    
    // ========== SUPERVISOR CONNECTION ==========
    socket.on('supervisor_connect', (data) => {
      try {
        const { supervisorCode } = data;
        
        if (!supervisorCode) {
          socket.emit('connection_error', { message: 'Supervisor code required' });
          return;
        }
        
        const cleanSupervisorCode = supervisorCode.toUpperCase();
        
        // Store connection
        supervisorConnections.set(cleanSupervisorCode, socket.id);
        socket.supervisorCode = cleanSupervisorCode;
        socket.userType = 'supervisor';
        
        console.log(`👨‍💼 Supervisor ${cleanSupervisorCode} connected`);
        
        socket.emit('connection_success', {
          supervisorCode: cleanSupervisorCode,
          status: 'connected'
        });
        
      } catch (error) {
        console.error('Supervisor connect error:', error);
        socket.emit('connection_error', { message: 'Connection failed' });
      }
    });
    
    // ========== STATUS UPDATE ==========
    socket.on('update_status', async (data) => {
      try {
        const { agentCode, status } = data;
        
        if (!agentCode || !status) {
          socket.emit('status_error', { message: 'agentCode and status required' });
          return;
        }
        
        // Save to database
        const statusUpdate = await Status.create({
          agentCode: agentCode.toUpperCase(),
          status: status,
          timestamp: new Date()
        });
        
        // Broadcast to all supervisors
        socket.broadcast.emit('agent_status_update', {
          agentCode: agentCode.toUpperCase(),
          status: status,
          timestamp: statusUpdate.timestamp
        });
        
        // Confirm to agent
        socket.emit('status_updated', {
          agentCode: agentCode.toUpperCase(),
          status: status,
          timestamp: statusUpdate.timestamp
        });
        
        console.log(`📊 ${agentCode} status updated to ${status}`);
        
      } catch (error) {
        console.error('Status update error:', error);
        socket.emit('status_error', { message: 'Failed to update status' });
      }
    });
    
    // ========== SEND MESSAGE ==========
    socket.on('send_message', async (data) => {
      try {
        const { fromCode, toCode, toTeamId, content, type } = data;
        
        // Save message to database
        const messageData = {
          fromCode: fromCode.toUpperCase(),
          content: content,
          type: type || 'direct',
          timestamp: new Date(),
          isRead: false
        };
        
        if (type === 'direct' && toCode) {
          messageData.toCode = toCode.toUpperCase();
        } else if (type === 'broadcast' && toTeamId) {
          messageData.toTeamId = parseInt(toTeamId);
        }
        
        const message = await Message.create(messageData);
        
        // Send to recipient(s)
        if (type === 'direct' && toCode) {
          // Send to specific agent
          const targetSocketId = activeConnections.get(toCode.toUpperCase());
          if (targetSocketId) {
            io.to(targetSocketId).emit('new_message', {
              messageId: message._id,
              fromCode: message.fromCode,
              content: message.content,
              timestamp: message.timestamp,
              type: 'direct'
            });
          }
        } else if (type === 'broadcast') {
          // Broadcast to all agents in team
          socket.broadcast.emit('new_message', {
            messageId: message._id,
            fromCode: message.fromCode,
            content: message.content,
            timestamp: message.timestamp,
            type: 'broadcast'
          });
        }
        
        // Confirm to sender
        socket.emit('message_sent', {
          messageId: message._id,
          status: 'delivered'
        });
        
        console.log(`💬 Message sent from ${fromCode} (${type})`);
        
      } catch (error) {
        console.error('Send message error:', error);
        socket.emit('message_error', { message: 'Failed to send message' });
      }
    });
    
    // ========== DISCONNECT HANDLING ==========
    socket.on('disconnect', () => {
      try {
        console.log(`🔌 Client disconnected: ${socket.id}`);
        
        if (socket.agentCode) {
          activeConnections.delete(socket.agentCode);
          
          // Notify supervisors that agent is offline
          socket.broadcast.emit('agent_disconnected', {
            agentCode: socket.agentCode,
            timestamp: new Date()
          });
          
          console.log(`👤 Agent ${socket.agentCode} disconnected`);
        }
        
        if (socket.supervisorCode) {
          supervisorConnections.delete(socket.supervisorCode);
          console.log(`👨‍💼 Supervisor ${socket.supervisorCode} disconnected`);
        }
        
      } catch (error) {
        console.error('Disconnect handling error:', error);
      }
    });
    
  });
}

module.exports = socketHandler;
```

---

## 🧠 **Database Models**

### **📄 Agent Model - models/Agent.js (SQLite)**

```javascript
const sqlite3 = require('sqlite3').verbose();
const path = require('path');

const DB_PATH = process.env.SQLITE_DB_PATH || '../database/sqlite/wallboard.db';

class Agent {
  static async findByCode(agentCode) {
    return new Promise((resolve, reject) => {
      const db = new sqlite3.Database(DB_PATH);
      
      const query = `
        SELECT a.*, t.team_name 
        FROM agents a 
        LEFT JOIN teams t ON a.team_id = t.team_id 
        WHERE a.agent_code = ? AND a.is_active = 1
      `;
      
      db.get(query, [agentCode], (err, row) => {
        if (err) {
          reject(err);
        } else {
          resolve(row || null);
        }
        db.close();
      });
    });
  }
  
  static async findByTeam(teamId) {
    return new Promise((resolve, reject) => {
      const db = new sqlite3.Database(DB_PATH);
      
      const query = `
        SELECT agent_code, agent_name, role, email, phone
        FROM agents 
        WHERE team_id = ? AND is_active = 1
        ORDER BY agent_name
      `;
      
      db.all(query, [teamId], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows || []);
        }
        db.close();
      });
    });
  }
}

module.exports = Agent;
```

### **💬 Message Model - models/Message.js (MongoDB)**

```javascript
const mongoose = require('mongoose');

const messageSchema = new mongoose.Schema({
  fromCode: {
    type: String,
    required: true,
    uppercase: true
  },
  toCode: {
    type: String,
    uppercase: true
  },
  toTeamId: {
    type: Number
  },
  content: {
    type: String,
    required: true,
    trim: true
  },
  type: {
    type: String,
    enum: ['direct', 'broadcast'],
    required: true
  },
  priority: {
    type: String,
    enum: ['low', 'normal', 'high'],
    default: 'normal'
  },
  isRead: {
    type: Boolean,
    default: false
  },
  readAt: {
    type: Date
  },
  timestamp: {
    type: Date,
    default: Date.now,
    index: true
  }
}, {
  collection: 'messages',
  timestamps: true
});

// Indexes for performance
messageSchema.index({ toCode: 1, timestamp: -1 });
messageSchema.index({ toTeamId: 1, timestamp: -1 });
messageSchema.index({ fromCode: 1, timestamp: -1 });

module.exports = mongoose.model('Message', messageSchema);
```

### **📊 Status Model - models/Status.js (MongoDB)**

```javascript
const mongoose = require('mongoose');

const statusSchema = new mongoose.Schema({
  agentCode: {
    type: String,
    required: true,
    uppercase: true,
    index: true
  },
  status: {
    type: String,
    enum: ['Available', 'Busy', 'Break', 'Offline'],
    required: true
  },
  timestamp: {
    type: Date,
    default: Date.now,
    index: true
  },
  teamId: {
    type: Number,
    index: true
  }
}, {
  collection: 'agent_status',
  timestamps: true
});

// Compound index for efficient queries
statusSchema.index({ agentCode: 1, timestamp: -1 });
statusSchema.index({ teamId: 1, timestamp: -1 });

module.exports = mongoose.model('Status', statusSchema);
```

---

## 🛡️ **Middleware**

### **🔐 Authentication Middleware - middleware/auth.js**

```javascript
const jwt = require('jsonwebtoken');

const authMiddleware = (req, res, next) => {
  try {
    // Get token from Authorization header
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        success: false,
        error: 'No token provided'
      });
    }
    
    const token = authHeader.substring(7); // Remove 'Bearer ' prefix
    
    // Verify and decode token
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'default-secret');
    
    // Add user info to request object
    req.user = {
      userId: decoded.userId,
      role: decoded.role,
      teamId: decoded.teamId
    };
    
    next();
    
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({
        success: false,
        error: 'Token expired'
      });
    }
    
    return res.status(401).json({
      success: false,
      error: 'Invalid token'
    });
  }
};

module.exports = authMiddleware;
```

### **❌ Error Handler Middleware - middleware/errorHandler.js**

```javascript
const errorHandler = (err, req, res, next) => {
  console.error('Error:', err);
  
  // Default error
  let error = {
    success: false,
    error: 'Internal server error'
  };
  
  // Mongoose validation error
  if (err.name === 'ValidationError') {
    const message = Object.values(err.errors).map(val => val.message).join(', ');
    error.error = message;
    return res.status(400).json(error);
  }
  
  // Mongoose duplicate key error
  if (err.code === 11000) {
    error.error = 'Duplicate field value entered';
    return res.status(400).json(error);
  }
  
  // JWT error
  if (err.name === 'JsonWebTokenError') {
    error.error = 'Invalid token';
    return res.status(401).json(error);
  }
  
  res.status(500).json(error);
};

module.exports = errorHandler;
```

---

## ⚙️ **Database Configuration - config/database.js**

```javascript
const sqlite3 = require('sqlite3').verbose();
const mongoose = require('mongoose');
const path = require('path');

// ========== SQLITE CONFIGURATION ==========
const SQLITE_DB_PATH = process.env.SQLITE_DB_PATH || '../database/sqlite/wallboard.db';

const initSQLite = () => {
  return new Promise((resolve, reject) => {
    const db = new sqlite3.Database(SQLITE_DB_PATH, (err) => {
      if (err) {
        console.error('SQLite connection error:', err);
        reject(err);
      } else {
        console.log('✅ Connected to SQLite database');
        resolve();
      }
      db.close();
    });
  });
};

// ========== MONGODB CONFIGURATION ==========
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/wallboard';

const connectMongoDB = async () => {
  try {
    await mongoose.connect(MONGODB_URI);
    console.log('✅ Connected to MongoDB');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    throw error;
  }
};

module.exports = {
  initSQLite,
  connectMongoDB
};
```

---

## 📦 **Package.json และ Scripts**

### **📋 Dependencies และ Scripts**

```json
{
  "name": "backend-server",
  "version": "1.0.0",
  "description": "Backend server for Agent Wallboard System",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest",
    "test:api": "node test/api-test.js",
    "test:db": "node test/db-test.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "socket.io": "^4.7.2",
    "sqlite3": "^5.1.6",
    "mongoose": "^7.5.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "jsonwebtoken": "^9.0.2"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^29.6.0"
  }
}
```

---

## 🧪 **การทดสอบ Backend APIs**

### **📋 Postman Collection Example**

```json
{
  "info": {
    "name": "Agent Wallboard Backend APIs",
    "description": "Complete API collection for testing"
  },
  "item": [
    {
      "name": "Health Check",
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "{{baseUrl}}/health",
          "host": ["{{baseUrl}}"],
          "path": ["health"]
        }
      }
    },
    {
      "name": "Agent Login",
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n  \"agentCode\": \"AG001\"\n}"
        },
        "url": {
          "raw": "{{baseUrl}}/api/auth/login",
          "host": ["{{baseUrl}}"],
          "path": ["api", "auth", "login"]
        }
      }
    },
    {
      "name": "Supervisor Login",
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n  \"supervisorCode\": \"SP001\"\n}"
        },
        "url": {
          "raw": "{{baseUrl}}/api/auth/login",
          "host": ["{{baseUrl}}"],
          "path": ["api", "auth", "login"]
        }
      }
    },
    {
      "name": "Update Agent Status",
      "request": {
        "method": "PUT",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Authorization",
            "value": "Bearer {{authToken}}"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n  \"status\": \"Busy\"\n}"
        },
        "url": {
          "raw": "{{baseUrl}}/api/agents/AG001/status",
          "host": ["{{baseUrl}}"],
          "path": ["api", "agents", "AG001", "status"]
        }
      }
    },
    {
      "name": "Send Direct Message",
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Authorization",
            "value": "Bearer {{authToken}}"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n  \"fromCode\": \"SP001\",\n  \"toCode\": \"AG001\",\n  \"content\": \"Please check your queue\",\n  \"type\": \"direct\"\n}"
        },
        "url": {
          "raw": "{{baseUrl}}/api/messages/send",
          "host": ["{{baseUrl}}"],
          "path": ["api", "messages", "send"]
        }
      }
    }
  ],
  "variable": [
    {
      "key": "baseUrl",
      "value": "http://localhost:3001"
    },
    {
      "key": "authToken",
      "value": ""
    }
  ]
}
```

### **🔧 Development Scripts:**

```bash
# เริ่ม development server พร้อม auto-restart
npm run dev

# ทดสอบ API endpoints ทั้งหมด
npm run test:api

# ตรวจสอบ database connections  
npm run test:db

# รันด้วย debug logging
DEBUG=* npm run dev
```

---

## 🔌 **WebSocket Events Reference**

### **📡 Events ที่ Client สามารถส่งได้:**

| Event | Description | Data Format | ใช้โดย |
|-------|-------------|-------------|---------|
| `agent_connect` | Agent เชื่อมต่อ WebSocket | `{agentCode: "AG001"}` | Agent Desktop |
| `supervisor_connect` | Supervisor เชื่อมต่อ WebSocket | `{supervisorCode: "SP001"}` | Supervisor Dashboard |
| `update_status` | เปลี่ยนสถานะ Agent | `{agentCode: "AG001", status: "Busy"}` | Agent Desktop |
| `send_message` | ส่งข้อความ | `{fromCode: "SP001", toCode: "AG001", content: "...", type: "direct"}` | Supervisor Dashboard |

### **📡 Events ที่ Server จะส่งให้ Client:**

| Event | Description | Data Format | ส่งให้ |
|-------|-------------|-------------|-------|
| `connection_success` | การเชื่อมต่อสำเร็จ | `{agentCode: "AG001", status: "connected"}` | ผู้ที่เชื่อมต่อ |
| `connection_error` | การเชื่อมต่อล้มเหลว | `{message: "Agent code required"}` | ผู้ที่เชื่อมต่อ |
| `agent_status_update` | สถานะ Agent เปลี่ยน | `{agentCode: "AG001", status: "Busy", timestamp: "..."}` | Supervisors |
| `new_message` | ข้อความใหม่ | `{messageId: "...", fromCode: "SP001", content: "...", type: "direct"}` | Recipients |
| `agent_connected` | Agent เข้าระบบ | `{agentCode: "AG001", timestamp: "..."}` | Supervisors |
| `agent_disconnected` | Agent ออกจากระบบ | `{agentCode: "AG001", timestamp: "..."}` | Supervisors |

---

## ✅ **Backend Completion Checklist**

### **📋 พื้นฐานที่ต้องทำงานได้:**
- [ ] Server เริ่มต้นได้โดยไม่มี errors
- [ ] เชื่อมต่อ SQLite และ MongoDB สำเร็จ
- [ ] API endpoints ตอบสนองถูกต้อง
- [ ] WebSocket connections ทำงานได้
- [ ] CORS settings อนุญาต frontend access
- [ ] Error handling แสดงข้อความที่เข้าใจได้

### **📋 Features ที่ต้องทำงาน:**
- [ ] Agent login ด้วย agent code
- [ ] Supervisor login ด้วย supervisor code
- [ ] Get team members สำหรับ supervisor
- [ ] Update agent status และ broadcast
- [ ] Send direct messages ระหว่าง supervisor และ agent  
- [ ] Send broadcast messages ถึง agents ทั้งหมด
- [ ] Real-time status updates ผ่าน WebSocket
- [ ] Message history retrieval

### **📋 Ready for Frontend Integration:**
- [ ] API documentation ชัดเจน
- [ ] Sample requests/responses พร้อม
- [ ] Error codes และ messages สม่ำเสมอ
- [ ] WebSocket events documented
- [ ] CORS configured for frontend URLs
- [ ] Authentication middleware ทำงาน
- [ ] Database models สมบูรณ์

---

## 🎯 **Next Steps**

หลังจากเข้าใจ Backend code แล้ว ขั้นตอนต่อไปคือ:

1. **🖥️ 6.6.3 Frontend Applications** - เรียนรู้การใช้ API ใน React และ Electron
2. **📅 6.2 Development Plan** - เริ่มพัฒนาตาม 14-day roadmap  
3. **🧪 6.4 Testing Strategy** - ทดสอบ integration ระหว่าง backend และ frontend

### **💡 เคล็ดลับสำหรับนักศึกษา:**
- **เริ่มจากการทำให้ทำงานได้ก่อน** แล้วค่อยปรับปรุง
- **ใช้ console.log อย่างเต็มที่** สำหรับ debugging
- **ทดสอบ API ด้วย Postman** ก่อนเชื่อมต่อ frontend
- **อ่าน error messages ให้ละเอียด** - มักจะบอกปัญหาได้ชัดเจน
- **Monitor database logs** เพื่อตรวจสอบ data flow

### **🔧 การ Debug Backend Issues:**
1. **ตรวจสอบ logs** ใน terminal ที่รัน server
2. **ดู error responses** จาก API calls
3. **ตรวจสอบ database connections** ด้วย health check endpoint
4. **ลอง restart server** หลังแก้ไขโค้ด
5. **ใช้ Postman** ทดสอบ API แยกจาก frontend

---

## 📞 **Need Help?**

**ถ้าเจอปัญหากับ Backend:**

**🔧 Server Issues:**
- **Port conflicts:** เปลี่ยน PORT ใน .env file
- **Module not found:** รัน `npm install` ใหม่
- **Permission denied:** ตรวจสอบ file permissions

**🗄️ Database Issues:**
- **SQLite errors:** ตรวจสอบ database file path
- **MongoDB errors:** ตรวจสอบ MongoDB service running
- **Connection timeouts:** ตรวจสอบ network และ firewall

**⚡ WebSocket Issues:**
- **Connection failed:** ตรวจสอบ CORS settings
- **Events not working:** ตรวจสอบ event names และ data format
- **Multiple connections:** ตรวจสอบ connection management

**🚀 Performance Issues:**
- **Slow API responses:** เพิ่ม database indexes
- **Memory leaks:** ตรวจสอบ unclosed database connections
- **High CPU usage:** ตรวจสอบ infinite loops หรือ heavy operations

**🎉 Backend Server พร้อมสำหรับการพัฒนา! ตอนนี้คุณมีพื้นฐานที่แข็งแกร่งสำหรับสร้าง Agent Wallboard System** 💪

**Happy Backend Development! 🚀**